{"version":3,"sources":["constants/colors.tsx","constants/strings.tsx","api_key.tsx","store/actions/auth.tsx","store/reducers/auth.tsx","utils/cache.tsx","store/actions/data/mixedData.tsx","store/reducers/data.tsx","store/actions/filters.tsx","store/reducers/filters.tsx","store/actions/game.tsx","store/reducers/game.tsx","store/configureStore.tsx","constants/nav.tsx","pages/menu/Menu.tsx","models/icon-card.tsx","data/game-types.tsx","components/grid-items/GridItemHome.tsx","components/UI/Loader.tsx","utils/tryLogin.tsx","pages/Home.tsx","pages/menu/Winners.tsx","pages/menu/Settings.tsx","pages/menu/Create.tsx","pages/NotFound.tsx","components/UI/TheotokosIcon.tsx","components/UI/Button.tsx","components/UI/Input.tsx","utils/auth-validation.tsx","components/UI/AuthCard.tsx","pages/Auth/Auth.tsx","components/Topbar.tsx","pages/menu/Donate.tsx","pages/game/MultiCategories.tsx","components/grid-items/GridTile.tsx","components/grid-items/imageHandler.tsx","components/grid-items/imageHandlerMix.tsx","components/grid-items/CategoryGridTileNoTimer.tsx","data/categories.tsx","utils/getGameStatusMulti.tsx","pages/game/MultiCategoriesNoTimer.tsx","models/question.tsx","utils/shuffle.tsx","store/actions/questions/index.tsx","store/actions/questions/mixedQuestions.tsx","store/actions/questions/questionsMultiOne.tsx","store/actions/questions/questionsMultiTwo.tsx","store/actions/questions/questionsMultiThree.tsx","store/actions/questions/questionsMultiFour.tsx","store/actions/questions/questionsTrueFalseOne.tsx","store/actions/questions/questionsTrueFalseTwo.tsx","store/actions/questions/questionsTrueFalseThree.tsx","store/actions/questions/questionsTrueFalseFour.tsx","hooks/useGetQuestionsList.tsx","hooks/useSaveCategory.tsx","components/CheckBox.tsx","components/UI/CustomModal.tsx","pages/game/mix/Categories.tsx","pages/game/mix/MixChooseCategories.tsx","pages/game/multi/MultiGameNoTimer.tsx","utils/getTotalPointsMixed.tsx","utils/updateNumOfTotalQuestionsMixed.tsx","hooks/useLoadQuestionsMixMulti.tsx","utils/saveGradeToCache.tsx","store/actions/data/index.tsx","store/actions/data/alfaOneData.tsx","utils/removeAsync.tsx","hooks/useSaveStadiumResultHandler.tsx","components/UI/TopMenu.tsx","components/UI/ChoiceText.tsx","components/UI/Line.tsx","components/UI/LinkText.tsx","components/UI/DetailedAnswer.tsx","components/game/FakeSuspense.tsx","animations/CorrectAnimation.tsx","animations/WrongAnimation.tsx","components/game/showQuestion.tsx","utils/quitGame.tsx","utils/checkAnswerForMixed.tsx","utils/checkAnswerHandlerMixMulti.tsx","pages/extras/GameOverPage.tsx","pages/extras/DownloadErrorScreen.tsx","pages/extras/NoQuestionsHereScreen.tsx","pages/game/mix/MixMultiGameNoTimer.tsx","pages/game/mix/MixMultiGameWithTimer.tsx","pages/game/mix/MixGameIsOn.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["colors","gr_brown","gr_brown_light","gr_brown_lighter","gr_gold_light","en_touto_nika_r","en_touto_nika_red","en_touto_nika_y","lightcyan","limegreen","cyan","silver","dimgray","moccasin","moccasin_light","moccasin_light_rgba","red_false","red_false_icon","red_true","red_true_icon","red","maroon","maroon_light","sandybrown","chocolate","chocolateRGBA","lightyellow","lightskyblue","lightseagrean","deepskyblue","lightblue","darkblue","steelblue","lightgray","check","circ_stroke","cerc_verde","ola1","ola2","ola3","salmon","strings","defaultChoiceColor","correctChoiceColor","wrongChoiceColor","alfaIsTrueMulti","alfaIsTrueMultiMixed","betaIsTrueMulti","betaIsTrueMultiMixed","categoriesFilters","createdQuestionsMultiFour","createdQuestionsMultiOne","createdQuestionsMultiThree","createdQuestionsMultiTwo","createdQuestionsTrueFalseFour","createdQuestionsTrueFalseOne","createdQuestionsTrueFalseThree","createdQuestionsTrueFalseTwo","deltaIsTrueMulti","deltaIsTrueMultiMixed","gameTypeMulti","gameTypeTrueFalse","gammaIsTrueMulti","gammaIsTrueMultiMixed","indexTrueFalse","indexTrueFalseMixed","indexTrueFalseNoTimer","lastQuestionMinutesMulti","lastQuestionMinutesMultiMixed","lastQuestionMinutesTrueFalse","lastQuestionMinutesTrueFalseMixed","lastQuestionSecondsMulti","lastQuestionSecondsMultiMixed","lastQuestionSecondsTrueFalse","lastQuestionSecondsTrueFalseMixed","localDataBaseMultiFour","localDataBaseMultiMixedFour","localDataBaseMultiMixedOne","localDataBaseMultiMixedThree","localDataBaseMultiMixedTwo","localDataBaseMultiOne","localDataBaseMultiThree","localDataBaseMultiTwo","localDatabaseTrueFalseFour","localDatabaseTrueFalseMixedFour","localDatabaseTrueFalseMixedOne","localDatabaseTrueFalseMixedThree","localDatabaseTrueFalseMixedTwo","localDatabaseTrueFalseOne","localDatabaseTrueFalseThree","localDatabaseTrueFalseTwo","min","mixedQuestionsAreOnTrueFalse","mixGameIsOnMulti","mixGameIsOnMultiNoTimer","mixGameIsOnTrueFalse","mixGameIsOnTrueFalseNoTimer","noIsChosen","numOfRemainQuestionsTrueFalseFour","numOfRemainQuestionsTrueFalseFourNoTimer","numOfRemainQuestionsTrueFalseMixed","numOfRemainQuestionsTrueFalseOne","numOfRemainQuestionsTrueFalseOneNoTimer","numOfRemainQuestionsTrueFalseThree","numOfRemainQuestionsTrueFalseThreeNoTimer","numOfRemainQuestionsTrueFalseTwo","numOfRemainQuestionsTrueFalseTwoNoTimer","numOfTotQuestionsMultiFour","numOfTotQuestionsMultiFourNoTimer","numOfTotQuestionsMultiMixed","numOfTotQuestionsMultiOne","numOfTotQuestionsMultiOneNoTimer","numOfTotQuestionsMultiThree","numOfTotQuestionsMultiThreeNoTimer","numOfTotQuestionsMultiTwo","numOfTotQuestionsMultiTwoNoTimer","numOfTotQuestionsTrueFalseFour","numOfTotQuestionsTrueFalseFourNoTimer","numOfTotQuestionsTrueFalseMixed","numOfTotQuestionsTrueFalseOne","numOfTotQuestionsTrueFalseOneNoTimer","numOfTotQuestionsTrueFalseThree","numOfTotQuestionsTrueFalseThreeNoTimer","numOfTotQuestionsTrueFalseTwo","numOfTotQuestionsTrueFalseTwoNoTimer","questionsMultiFour","questionsMultiFourNoTimer","questionsMultiMixed","questionsMultiOne","questionsMultiOneNoTimer","questionsMultiThree","questionsMultiThreeNoTimer","questionsMultiTwo","questionsMultiTwoNoTimer","questionsRightChoices","questionsRightChoicesNoTimer","questionsTrueFalseFour","questionsTrueFalseFourNoTimer","questionsTrueFalseMixed","questionsTrueFalseOne","questionsTrueFalseOneNoTimer","questionsTrueFalseThree","questionsTrueFalseThreeNoTimer","questionsTrueFalseTwo","questionsTrueFalseTwoNoTimer","refreshToken","savedPoints","sec","skipIntroScreen","totalPointsMultiFour","totalPointsMultiFourNoTimer","pointsTypeMultiMixed","totalPointsMultiOne","totalPointsMultiOneNoTimer","totalPointsMultiThree","totalPointsMultiThreeNoTimer","totalPointsMultiTwo","totalPointsMultiTwoNoTimer","totalPointsTrueFalseFour","totalPointsTrueFalseFourNoTimer","pointsTypeTrueFalseMixed","totalPointsTrueFalseOne","totalPointsTrueFalseOneNoTimer","totalPointsTrueFalseThree","totalPointsTrueFalseThreeNoTimer","totalPointsTrueFalseTwo","totalPointsTrueFalseTwoNoTimer","totalTimeLeftMultiFour","totalTimeLeftMultiOne","totalTimeLeftMultiThree","totalTimeLeftMultiTwo","totalTimeLeftTrueFalseFour","totalTimeLeftTrueFalseMixed","totalTimeLeftTrueFalseOne","totalTimeLeftTrueFalseThree","totalTimeLeftTrueFalseTwo","userData","userName","useTimerMultiMixed","useTimerTrueFalseMixed","yesIsChosen","API_KEY","AUTHENTICATE","LOG_OUT","USER_PROFILE_PICTURE_URL","USERS_PROFILE_PICTURE_URLS","USERS_NAMES","TRIED_AUTOLOGIN","ALLOW_ENTRANCE","FORGOT_PASSWORD","SET_SKIP_INTRO_SCREEN","triedAutoLogin","set","type","authenticate","token","userId","expiryTime","userEmail","dispatch","signup","email","password","a","fetch","method","headers","body","JSON","stringify","returnSecureToken","response","ok","json","errorResData","errorId","error","message","alert","Error","resData","idToken","localId","parseInt","expiresIn","expirationDate","Date","getTime","saveDataToStorage","login","console","log","undefined","localStorage","getItem","oldEmail","transformedData","parse","removeItem","setItem","expiryDate","toISOString","_storeData","refreshData","id_token","user_id","expires_in","refresh_token","changeUserName","getState","auth","fetchResponse","fetchUserName","key","initialState","allowEntrance","forgotPassword","userProfilePictureUrl","usersNames","usersProfilePictureUrls","state","action","cache","value","get","item","remove","FETCH_All_USERS_DATA","allUsersData","data","UPLOAD_CATEGORIES_FILTERS","DELETE_PREVIOUS_CATEGORIES_FILTERS","FETCH_CATEGORIES_FILTERS","uploadCategoriesFilters","gameType","appliedCategoriesFilters","store","deletePreviousCategoriesFilters","fetchCategoriesFilters","filtersResponse","filtersResData","filters","LOGIN_MODE","TIMER_STATE","GAME_STATE","GAME_TYPE_TITLE","GAME_ON","SAVE_POINTS","SAVE_POINTS_TYPE","gameState","id","title","gameTypeTitle","gameOn","savePoints","points","pointsType","mode","timer","pointsMultiMixed","pointsTrueFalseMixed","game","appReducer","combineReducers","AuthReducer","DataReducer","fliters","FiltersReducer","GeneralReducer","persistConfig","storage","persistedReducer","persistReducer","configureStore","createStore","composeEnhancers","applyMiddleware","thunk","persistor","persistStore","window","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","nav","home","winners","settings","create","donate","not_found","multiCategories","multiCategoriesNoTimer","multiGameNoTimer","multiGameWithTimer","trueFalseCategories","trueFalseCategoriesNoTimer","trueFalseGameNoTimer","trueFalseGameWithTimer","trueFalseMixedGameNoTimer","mixGameIsOn","mixChooseCategories","mixMultiGameWithTimer","mixMultiGameNoTimer","mixTrueFalseGameWithTimer","mixTrueFalseGameNoTimer","createHome","createMultiCategories","createNavigator","createMultiOverview","createTrueFalse","createTrueFalseCategories","createTrueFalseOverview","editMultiQuestion","editTrueFalseQuestion","gameInfo","gameInfoNavigator","gameNavigator","intro","Menu","menuOpen","setMenuOpen","useDispatch","userIsLoggedIn","menuHandler","className","onClick","to","IconCard","this","GAME_TYPES","theotokos","GridItemHome","props","image","src","alt","Loader","tryLogin","setError","authActions","Home","history","useHistory","useState","useSelector","isAuth","useEffect","playHandler","push","map","bind","Winners","Settings","Create","NotFound","TheotokosIcon","Button","disabled","style","onMouseEnter","onMouseLeave","Input","name","onChange","onBlur","placeholder","autoFocus","errors","confirmPassword","nameIsValid","setErrors","trim","length","emailIsValid","test","toLowerCase","passwordIsValid","passwordNoMatch","formIsValid","loginFormIsValid","authFormIsValid","errorsInitialState","noSubEnterButton","height","fontSize","borderRadius","boxShadow","border","AuthCard","hover","setHover","setLogin","setName","setEmail","setPassword","setConfirmPassword","isLoading","setIsLoading","handleHover","handleChange","event","target","handleSubmit","useCallback","preventDefault","replace","goToLoginButtom","width","color","backgroundColor","Auth","Topbar","setTimer","gameTitle","timerState","toggleTimerIcon","size","Donate","MultiCategories","GridTile","borderColor","borderWidth","imageHandler","gamesStatus","adjustBorderColor","CategoryGridTileNoTimer","navigationName","borderC","borderW","img","imageHandlerMix","CATEGORIES","getGameStatusMulti","setGamesStatus","checkCategories","then","MultiCategoriesNoTimer","setMixGameIsOn","mixGameIsOnNoTimer","setMixGameIsOnNoTimer","mixGameIsOnTF","setMixGameIsOnTF","mixGameIsOnTFNoTimer","setMixGameIsOnTFNoTimer","checking","isOn","pathname","question","info","accepted","index","categoryIds","ownerId","answer","source","choice_Alpha","choice_Beta","choice_Gamma","choice_Delta","right_choice","shuffle","array","i","j","Math","floor","random","fetchQuestionsMultiMixed","mixedQuestions","check_one","check_two","check_three","check_four","questions","hint","shuffledQuestions","fetchQuestionsForMixedOne","maxIndex","URI","questionsResponse","questResData","loadedQuestions","acceptedQuestions","forEach","fetchQuestionsForMixedTwo","fetchQuestionsForMixedThree","fetchQuestionsForMixedFour","fetchQuestionsForTrueFalseOneMixed","fetchQuestionsForTrueFalseTwoMixed","fetchQuestionsForTrueFalseThreeMixed","fetchQuestionsForTrueFalseFourMixed","useGetQuestionsList","oneIsTrue","twoIsTrue","threeIsTrue","fourIsTrue","categoryIsChosen","setCategoryIsChosen","getQuestionsFromServer","category","questionsActions","checkHandler","localDatabase","useSaveCategory","setOneIsTrue","setTwoIsTrue","setThreeIsTrue","setFourIsTrue","filtersAreApplied","setFiltersAreApplied","deleteFilters","setDeleteFilters","loadFilters","savedFilters","one","two","three","four","appliedFilters","filtersActions","getFilters","saveOne","saveTwo","saveThree","saveFour","CheckBox","text","checked","CustomModal","textOne","textTwo","buttonOneTitle","buttonTwoTitle","onClickOne","onClickTwo","margin","Categories","showModal","setShowModal","startMixGame","MixChooseCategories","MultiGameNoTimer","getTotalPointsMixed","totalPoints","setTotalPoints","storedTotalPoints","updateNumOfTotalQuestionsMixed","numOfTotalQuestions","setNumOfTotalQuestions","numOfTotQ","newValue","saveCache","saveMulti","String","saveTrueFalse","useLoadQuestionsMixedMulti","loadQuestionsError","setLoadQuestionsError","numOfDownloadedQuestions","setNumOfDownloadedQuestions","selectedQuestion","setSelectedQuestion","stadiumIsFinished","setStadiumIsFinished","loadQuestions","newSelectedQuestion","splice","pop","saveGradeToCache","sum","saveData","date","newTotalPoints","multipleChoiceRemoveAsync","categoryId","noTimerRemoveAsync","trueFalseRemoveAsync","noTimerTrueFalseRemoveAsync","removeAsyncMultiMixed","removeAsyncTrueFalseMixed","removeChoicesfromAsyncStorage","useSaveStadiumResultHandler","userIsLogedIn","quit","isUpLoading","setIsUpLoading","onLine","navigator","saveStadiumResult","dataActions","TopMenu","categoryTitle","ChoiceText","choiceIsMade","choice","choiceColor","choiceLetter","choiceText","saveAnswer","setChoiceSave","setStyle","styles","padding","marginVertical","marginHorizontal","shadowColor","shadowOpacity","shadowOffset","shadowRadius","transition","none","setTimeout","Line","LinkText","children","DetailedAnswer","onRefresh","breakHandler","whiteSpace","href","rel","match","FakeSuspense","delay","fallback","isShown","setIsShown","playAlert","require","CorrectAnimation","fadeout","setFadeout","container","useRef","content","current","lottie","loadAnimation","renderer","loop","autoplay","animationData","ref","WrongAnimation","showQuestion","alfaIsTrue","betaIsTrue","gammaIsTrue","deltaIsTrue","checkAlfa","checkBeta","checkGamma","checkDelta","choiceSave","correctChoice","showAnswer","setCheckAlfa","setCheckBeta","setCheckGamma","setCheckDelta","setShowAnswer","modalVisible","onbeforeunload","when","quitGame","checkAnswerForMixed","answerIsCorrect","asynNames","checkAnswerHandlerMixedMulti","setChoiceColor","setCorrectChoice","alfaIsTrueMixed","betaIsTrueMixed","gammaIsTrueMixed","deltaIsTrueMixed","rightChoice","corChoice","GameOverPage","minutesLeft","secondsLeft","stadiumCounter","gradeSaved","setGradeSaved","DownloadErrorScreen","NoQuestionsHereScreen","MixMultiGameNoTimer","setRefreshing","useLoadQuestionsMixMulti","checkAnswerHandlerMixMulti","MixMultiGameWithTimer","withRouter","location","continueSameGameHanlder","startNewGameHandler","createBrowserHistory","App","userLoggedIn","document","addEventListener","render","TransitionGroup","CSSTransition","timeout","classNames","mountOnEnter","unmountOnExit","path","component","exact","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","loading","getElementById"],"mappings":"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","file":"static/js/main.6cacdf8e.chunk.js","sourcesContent":["const colors = {\n  gr_brown: \"#AD3333\",\n  gr_brown_light: \"#AE4444\",\n  gr_brown_lighter: \"#ECE3E3\",\n  gr_gold_light: \"#FAF4CC\",\n  en_touto_nika_r: \"#670001\",\n  en_touto_nika_red: \"#921718\",\n  en_touto_nika_y: \"#f0da45\",\n  lightcyan: \"#E0FFFF\",\n  limegreen: \"#32CD32\",\n  cyan: \"#00FFFF\",\n  silver: \"#C0C0C0\",\n  dimgray: \"#696969\",\n  moccasin: \"#FFE4B5\",\n  moccasin_light: \"#FFF4DF\",\n  moccasin_light_rgba: \"rgba(255, 244, 223, 0.5)\",\n  red_false: \"rgba(255,255,255,.2)\",\n  red_false_icon: \"rgba(255,255,255,.5)\",\n  red_true: \"rgba(255,255,255,.3)\",\n  red_true_icon: \"rgba(255,255,255,.5)\",\n  red: \"#ffffff\",\n  maroon: \"#800000\",\n  maroon_light: '#882222',\n  sandybrown: \"#F4A460\",\n  chocolate: \"#D2691E\",\n  chocolateRGBA: \"rgba(210,105,30, 0.3)\",\n  lightyellow: \"#FFFFE0\",\n  lightskyblue: \"#87CEFA\",\n  lightseagrean: \"#FFFFF0\",\n  deepskyblue: \"#00BFFF\",\n  lightblue: \"#ADD8E6\",\n  darkblue: \"#00008B\",\n  steelblue: \"#4682B4\",\n  lightgray: \"#D3D3D3\",\n  check: \"#F5F8A0\",\n  circ_stroke: \"#59CFD6\",\n  cerc_verde: \"#09324D\",\n  ola1: \"#25689C\",\n  ola2: \"#F0F393\",\n  ola3: \"#7FE8EE\",\n  salmon: '#FA8072'\n};\n\nexport default colors;","import colors from \"./colors\";\n\nconst strings = {\n  defaultChoiceColor: colors.moccasin_light,\n  correctChoiceColor: colors.limegreen,\n  wrongChoiceColor: colors.salmon,\n  alfaIsTrueMulti: \"alfaIsTrueMulti\",\n  alfaIsTrueMultiMixed: \"alfaIsTrueMultiMixed\",\n  betaIsTrueMulti: \"betaIsTrueMulti\",\n  betaIsTrueMultiMixed: \"betaIsTrueMultiMixed\",\n  categoriesFilters: \"categoriesFilters\",\n  createdQuestionsMultiFour: \"createdQuestionsMultiFour\",\n  createdQuestionsMultiOne: \"createdQuestionsMultiOne\",\n  createdQuestionsMultiThree: \"createdQuestionsMultiThree\",\n  createdQuestionsMultiTwo: \"createdQuestionsMultiTwo\",\n  createdQuestionsTrueFalseFour: \"createdQuestionsTrueFalseFour\",\n  createdQuestionsTrueFalseOne: \"createdQuestionsTrueFalseOne\",\n  createdQuestionsTrueFalseThree: \"createdQuestionsTrueFalseThree\",\n  createdQuestionsTrueFalseTwo: \"createdQuestionsTrueFalseTwo\",\n  deltaIsTrueMulti: \"deltaIsTrueMulti\",\n  deltaIsTrueMultiMixed: \"deltaIsTrueMultiMixed\",\n  gameTypeMulti: 'Multi',\n  gameTypeTrueFalse: 'TrueFalse',\n  gammaIsTrueMulti: \"gammaIsTrueMulti\",\n  gammaIsTrueMultiMixed: \"gammaIsTrueMultiMixed\",\n  indexTrueFalse: \"indexTrueFalse\",\n  indexTrueFalseMixed: \"indexTrueFalseMixed\",\n  indexTrueFalseNoTimer: \"indexTrueFalseNoTimer\",\n  lastQuestionMinutesMulti: \"lastQuestionMinutesMulti\",\n  lastQuestionMinutesMultiMixed: \"lastQuestionMinutesMultiMixed\",\n  lastQuestionMinutesTrueFalse: \"lastQuestionMinutesTrueFalse\",\n  lastQuestionMinutesTrueFalseMixed: \"lastQuestionMinutesTrueFalseMixed\",\n  lastQuestionSecondsMulti: \"lastQuestionSecondsMulti\",\n  lastQuestionSecondsMultiMixed: \"lastQuestionSecondsMultiMixed\",\n  lastQuestionSecondsTrueFalse: \"lastQuestionSecondsTrueFalse\",\n  lastQuestionSecondsTrueFalseMixed: \"lastQuestionSecondsTrueFalseMixed\",\n  localDataBaseMultiFour: \"localDataBaseMultiFour\",\n  localDataBaseMultiMixedFour: \"localDataBaseMultiMixedFour\",\n  localDataBaseMultiMixedOne: \"localDataBaseMultiMixedOne\",\n  localDataBaseMultiMixedThree: \"localDataBaseMultiMixedThree\",\n  localDataBaseMultiMixedTwo: \"localDataBaseMultiMixedTwo\",\n  localDataBaseMultiOne: \"localDataBaseMultiOne\",\n  localDataBaseMultiThree: \"localDataBaseMultiThree\",\n  localDataBaseMultiTwo: \"localDataBaseMultiTwo\",\n  localDatabaseTrueFalseFour: \"localDatabaseTrueFalseFour\",\n  localDatabaseTrueFalseMixedFour: \"localDatabaseTrueFalseMixedFour\",\n  localDatabaseTrueFalseMixedOne: \"localDatabaseTrueFalseMixedOne\",\n  localDatabaseTrueFalseMixedThree: \"localDatabaseTrueFalseMixedThree\",\n  localDatabaseTrueFalseMixedTwo: \"localDatabaseTrueFalseMixedTwo\",\n  localDatabaseTrueFalseOne: \"localDatabaseTrueFalseOne\",\n  localDatabaseTrueFalseThree: \"localDatabaseTrueFalseThree\",\n  localDatabaseTrueFalseTwo: \"localDatabaseTrueFalseTwo\",\n  min: \"min\",\n  mixedQuestionsAreOnTrueFalse: \"mixedQuestionsAreOnTrueFalse\",\n  mixGameIsOnMulti: \"mixGameIsOnMulti\",\n  mixGameIsOnMultiNoTimer: \"mixGameIsOnMultiNoTimer\",\n  mixGameIsOnTrueFalse: \"mixGameIsOnTrueFalse\",\n  mixGameIsOnTrueFalseNoTimer: \"mixGameIsOnTrueFalseNoTimer\",\n  noIsChosen: \"noIsChosen\",\n  numOfRemainQuestionsTrueFalseFour: \"numOfRemainQuestionsTrueFalseFour\",\n  numOfRemainQuestionsTrueFalseFourNoTimer:\n    \"numOfRemainQuestionsTrueFalseFourNoTimer\",\n  numOfRemainQuestionsTrueFalseMixed: \"numOfRemainQuestionsTrueFalseMixed\",\n  numOfRemainQuestionsTrueFalseOne: \"numOfRemainQuestionsTrueFalseOne\",\n  numOfRemainQuestionsTrueFalseOneNoTimer:\n    \"numOfRemainQuestionsTrueFalseOneNoTimer\",\n  numOfRemainQuestionsTrueFalseThree: \"numOfRemainQuestionsTrueFalseThree\",\n  numOfRemainQuestionsTrueFalseThreeNoTimer:\n    \"numOfRemainQuestionsTrueFalseThreeNoTimer\",\n  numOfRemainQuestionsTrueFalseTwo: \"numOfRemainQuestionsTrueFalseTwo\",\n  numOfRemainQuestionsTrueFalseTwoNoTimer:\n    \"numOfRemainQuestionsTrueFalseTwoNoTimer\",\n  numOfTotQuestionsMultiFour: \"numOfTotQuestionsMultiFour\",\n  numOfTotQuestionsMultiFourNoTimer: \"numOfTotQuestionsMultiFourNoTimer\",\n  numOfTotQuestionsMultiMixed: \"numOfTotQuestionsMultiMixed\",\n  numOfTotQuestionsMultiOne: \"numOfTotQuestionsMultiOne\",\n  numOfTotQuestionsMultiOneNoTimer: \"numOfTotQuestionsMultiOneNoTimer\",\n  numOfTotQuestionsMultiThree: \"numOfTotQuestionsMultiThree\",\n  numOfTotQuestionsMultiThreeNoTimer: \"numOfTotQuestionsMultiThreeNoTimer\",\n  numOfTotQuestionsMultiTwo: \"numOfTotQuestionsMultiTwo\",\n  numOfTotQuestionsMultiTwoNoTimer: \"numOfTotQuestionsMultiTwoNoTimer\",\n  numOfTotQuestionsTrueFalseFour: \"numOfTotQuestionsTrueFalseFour\",\n  numOfTotQuestionsTrueFalseFourNoTimer:\n    \"numOfTotQuestionsTrueFalseFourNoTimer\",\n  numOfTotQuestionsTrueFalseMixed: \"numOfTotQuestionsTrueFalseMixed\",\n  numOfTotQuestionsTrueFalseOne: \"numOfTotQuestionsTrueFalseOne\",\n  numOfTotQuestionsTrueFalseOneNoTimer: \"numOfTotQuestionsTrueFalseOneNoTimer\",\n  numOfTotQuestionsTrueFalseThree: \"numOfTotQuestionsTrueFalseThree\",\n  numOfTotQuestionsTrueFalseThreeNoTimer:\n    \"numOfTotQuestionsTrueFalseThreeNoTimer\",\n  numOfTotQuestionsTrueFalseTwo: \"numOfTotQuestionsTrueFalseTwo\",\n  numOfTotQuestionsTrueFalseTwoNoTimer: \"numOfTotQuestionsTrueFalseTwoNoTimer\",\n  questionsMultiFour: \"questionsMultiFour\",\n  questionsMultiFourNoTimer: \"questionsMultiFourNoTimer\",\n  questionsMultiMixed: \"questionsMultiMixed\",\n  questionsMultiOne: \"questionsMultiOne\",\n  questionsMultiOneNoTimer: \"questionsMultiOneNoTimer\",\n  questionsMultiThree: \"questionsMultiThree\",\n  questionsMultiThreeNoTimer: \"questionsMultiThreeNoTimer\",\n  questionsMultiTwo: \"questionsMultiTwo\",\n  questionsMultiTwoNoTimer: \"questionsMultiTwoNoTimer\",\n  questionsRightChoices: \"questionsRightChoices\",\n  questionsRightChoicesNoTimer: \"questionsRightChoicesNoTimer\",\n  questionsTrueFalseFour: \"questions_TrueFalseFour\",\n  questionsTrueFalseFourNoTimer: \"questionsTrueFalseFourNoTimer\",\n  questionsTrueFalseMixed: \"questionsTrueFalseMixed\",\n  questionsTrueFalseOne: \"questionsTrueFalseOne\",\n  questionsTrueFalseOneNoTimer: \"questionsTrueFalseOneNoTimer\",\n  questionsTrueFalseThree: \"questionsTrueFalseThree\",\n  questionsTrueFalseThreeNoTimer: \"questionsTrueFalseThreeNoTimer\",\n  questionsTrueFalseTwo: \"questionsTrueFalseTwo\",\n  questionsTrueFalseTwoNoTimer: \"questionsTrueFalseTwoNoTimer\",\n  refreshToken: \"refreshToken\",\n  savedPoints: \"savedPoints\",\n  sec: \"sec\",\n  skipIntroScreen: \"skipIntroScreen\",\n  totalPointsMultiFour: \"totalPointsMultiFour\",\n  totalPointsMultiFourNoTimer: \"totalPointsMultiFourNoTimer\",\n  pointsTypeMultiMixed: \"pointsTypeMultiMixed\",\n  totalPointsMultiOne: \"totalPointsMultiOne\",\n  totalPointsMultiOneNoTimer: \"totalPointsMultiOneNoTimer\",\n  totalPointsMultiThree: \"totalPointsMultiThree\",\n  totalPointsMultiThreeNoTimer: \"totalPointsMultiThreeNoTimer\",\n  totalPointsMultiTwo: \"totalPointsMultiTwo\",\n  totalPointsMultiTwoNoTimer: \"totalPointsMultiTwoNoTimer\",\n  totalPointsTrueFalseFour: \"totalPointsTrueFalseFour\",\n  totalPointsTrueFalseFourNoTimer: \"totalPointsTrueFalseFourNoTimer\",\n  pointsTypeTrueFalseMixed: \"pointsTypeTrueFalseMixed\",\n  totalPointsTrueFalseOne: \"totalPointsTrueFalseOne\",\n  totalPointsTrueFalseOneNoTimer: \"totalPointsTrueFalseOneNoTimer\",\n  totalPointsTrueFalseThree: \"totalPointsTrueFalseThree\",\n  totalPointsTrueFalseThreeNoTimer: \"totalPointsTrueFalseThreeNoTimer\",\n  totalPointsTrueFalseTwo: \"totalPointsTrueFalseTwo\",\n  totalPointsTrueFalseTwoNoTimer: \"totalPointsTrueFalseTwoNoTimer\",\n  totalTimeLeftMultiFour: \"totalTimeLeftMultiFour\",\n  // totalTimeLeftMultiMixed: \"totalTimeLeftMultiMixed\",\n  totalTimeLeftMultiOne: \"totalTimeLeftMultiOne\",\n  totalTimeLeftMultiThree: \"totalTimeLeftMultiThree\",\n  totalTimeLeftMultiTwo: \"totalTimeLeftMultiTwo\",\n  totalTimeLeftTrueFalseFour: \"totalTimeLeftTrueFalseFour\",\n  totalTimeLeftTrueFalseMixed: \"totalTimeLeftTrueFalseMixed\",\n  totalTimeLeftTrueFalseOne: \"totalTimeLeftTrueFalseOne\",\n  totalTimeLeftTrueFalseThree: \"totalTimeLeftTrueFalseThree\",\n  totalTimeLeftTrueFalseTwo: \"totalTimeLeftTrueFalseTwo\",\n  userData: \"userData\",\n  userName: \"userName\",\n  useTimerMultiMixed: \"useTimerMultiMixed\",\n  useTimerTrueFalseMixed: \"useTimerTrueFalseMixed\",\n  yesIsChosen: \"yesIsChosen\",\n};\n\nexport default strings;","const API_KEY = \"AIzaSyCkVlDAonkvTzKJkVpAlxMnCZmVil1qbg8\";\n\nexport default API_KEY;","import strings from \"../../constants/strings\";\nimport API_KEY from \"../../api_key\";\n// import firebase from \"../../firebase/firebase\";\n\nexport const AUTHENTICATE = \"AUTHENTICATE\";\nexport const LOG_OUT = \"LOG_OUT\";\nexport const USER_PROFILE_PICTURE_URL = \"USER_PROFILE_PICTURE_URL\";\nexport const USERS_PROFILE_PICTURE_URLS = \"USERS_PROFILE_PICTURE_URLS\";\nexport const USERS_NAMES = \"USERS_NAMES\";\nexport const TRIED_AUTOLOGIN = \"TRIED_AUTOLOGIN\";\nexport const ALLOW_ENTRANCE = \"ALLOW_ENTRANCE\";\nexport const FORGOT_PASSWORD = \"FORGOT_PASSWORD\";\nexport const SET_SKIP_INTRO_SCREEN = \"SET_SKIP_INTRO_SCREEN\";\n\n\n// For Navigation\nexport const forgotPassword = (set: boolean) => {\n  return {\n    type: FORGOT_PASSWORD,\n    set,\n  };\n};\nexport const allowEntrance = (set: boolean) => {\n  return {\n    type: ALLOW_ENTRANCE,\n    set,\n  };\n};\nexport const triedAutoLogin = (set: boolean) => {\n  return {\n    type: TRIED_AUTOLOGIN,\n    set,\n  };\n};\nexport const authenticate = (token: string, userId: string, expiryTime: number, userEmail?: string) => {\n  return (dispatch: Function) => {\n    // dispatch(setLogoutTimer(expiryTime));\n    dispatch({\n      type: AUTHENTICATE,\n      token,\n      userId,\n      userEmail,\n    });\n  };\n};\n\nexport const signup = (email: string, password: string) => {\n  return async (dispatch: Function) => {\n    const response = await fetch(\n      \"https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=\" +\n      API_KEY,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          email: email,\n          password: password,\n          returnSecureToken: true,\n        }),\n      }\n    );\n\n    if (!response.ok) {\n      const errorResData = await response.json();\n      const errorId = errorResData.error.message;\n      let message = \"Σφάλμα κατά την διαδικασία εγγραφής!\";\n      if (errorId === \"EMAIL_EXISTS\") {\n        message = \"Αυτή η ηλεκτρονική διεύθυνση ήδη υπάρχει!\";\n      } else if (errorId === \"OPERATION_NOT_ALLOWED\") {\n        message =\n          \"Η δυνατότητα σύνδεσης με ηλεκτρονική διεύθυνση έχει απενεργοποιηθεί!\";\n      } else if (errorId === \"TOO_MANY_ATTEMPTS_TRY_LATER\") {\n        message =\n          \"Πολλές αποτυχίες... δοκίμασε ξανά αργότερα!\";\n      }\n      alert(message);\n      throw new Error(message);\n    }\n\n    const resData = await response.json(); // transforms the data from json to javascript object\n\n    dispatch(\n      authenticate(\n        resData.idToken,\n        resData.localId,\n        parseInt(resData.expiresIn) * 1000,\n        email\n      )\n    );\n    // The first new Date converts the second's huge number of miliseconds in a concrete date.\n    const expirationDate = new Date(\n      new Date().getTime() + parseInt(resData.expiresIn) * 1000\n    );\n    saveDataToStorage(\n      resData.idToken,\n      resData.localId,\n      expirationDate,\n      resData.email,\n      resData.refreshToken\n    );\n  };\n};\n\nexport const login = (email: string, password: string) => {\n  return async (dispatch: Function) => {\n    try {\n      const response = await fetch(\n        \"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=\" +\n        API_KEY,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            email: email,\n            password: password,\n            returnSecureToken: true,\n          }),\n        }\n      );\n\n      if (!response.ok) {\n        const errorResData = await response.json();\n        const errorId = errorResData.error.message;\n        let message = \"Σφάλμα κατά την διαδικασία σύνδεσης!\";\n        if (errorId === \"EMAIL_NOT_FOUND\") {\n          message = \"Η ηλεκτρονική διεύθυνση δεν βρέθηκε!\";\n        } else if (errorId === \"INVALID_PASSWORD\") {\n          message = \"Αυτός ο κωδικός είναι άκυρος!\";\n        } else if (errorId === \"USER_DISABLED\") {\n          message = \"Ο λογαριασμός σας έχει απενεργοποιηθεί!\";\n        }\n        throw new Error(message);\n      }\n      const resData = await response.json(); // transforms the data from json to javascript object\n      console.log(resData);\n\n      dispatch(\n        authenticate(\n          resData.idToken,\n          resData.localId,\n          parseInt(resData.expiresIn) * 1000,\n          email\n        )\n      );\n      // const expirationDate = new Date(new Date().getTime() + 20 * 1000);\n\n      // The first new Date converts the second's huge number of miliseconds in a concrete date.\n      const expirationDate = new Date(\n        new Date().getTime() + parseInt(resData.expiresIn) * 1000\n      );\n      saveDataToStorage(\n        resData.idToken,\n        resData.localId,\n        expirationDate,\n        resData.email,\n        resData.refreshToken\n      );\n    } catch (error) {\n      throw error;\n    }\n  };\n};\n\nexport const logout = () => {\n  return async (dispatch: Function) => {\n    await localStorage.removeItem(strings.userData);\n    await localStorage.removeItem(strings.refreshToken);\n    dispatch({ type: LOG_OUT });\n  };\n};\n\n// const clearLogoutTimer = () => {\n// \tif (timer) {\n// \t\tclearTimeout(timer);\n// \t}\n// };\n\n// This is for automatic logging out the user...\n// Gets dispatched in `authenticate` action\n// const setLogoutTimer = (expirationTime) => {\n// \treturn (dispatch: Function) => {\n// \t\ttimer = setTimeout(() => {\n// \t\t\tdispatch(logout());\n// \t\t}, expirationTime);\n// \t};\n// };\n\nconst saveDataToStorage = (\n  token: string,\n  userId: string,\n  expirationDate: Date,\n  email: string,\n  refreshToken: string\n) => {\n  const _storeData = async () => {\n    try {\n      // email is undefined if we come here from refreshData.\n      // So we get it from localStorage\n      if (email === undefined) {\n        const userData = await localStorage.getItem(strings.userData);\n        let oldEmail = \"\";\n        if (userData) {\n          // parse converts a string to an object or array\n          const transformedData = JSON.parse(userData);\n          const { userEmail } = transformedData;\n          oldEmail = userEmail;\n        }\n        await localStorage.removeItem(strings.userData);\n        await localStorage.setItem(\n          strings.userData,\n          // stringify converts an object to a string\n          JSON.stringify({\n            token: token,\n            userId: userId,\n            expiryDate: expirationDate.toISOString(), // convert it to a string in a standardize format\n            userEmail: oldEmail, // for showing on every screen\n          })\n        );\n      } else {\n        await localStorage.removeItem(strings.userData);\n        // data must be in string format!\n        await localStorage.setItem(\n          strings.userData,\n          // stringify converts an object to a string\n          JSON.stringify({\n            token: token,\n            userId: userId,\n            expiryDate: expirationDate.toISOString(), // convert it to a string in a standardize format\n            userEmail: email, // for showing on every screen\n          })\n        );\n      }\n\n      await localStorage.setItem(strings.refreshToken, refreshToken);\n    } catch (error) {\n      // Error saving data\n    }\n  };\n  _storeData();\n};\n\nexport const refreshData = (refreshToken: string) => {\n  return async (dispatch: Function) => {\n    try {\n      // console.log('refreshData', refreshToken);\n\n      const response = await fetch(\n        \"https://securetoken.googleapis.com/v1/token?key=\" + API_KEY,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n          },\n          body: \"grant_type=refresh_token&refresh_token=\" + refreshToken,\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των δεδομένων σύνδεσης στο λογαριασμό σας δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n      const resData = await response.json(); // transforms the data from json to javascript object\n      // console.log('resData', !!resData);\n\n      dispatch(\n        authenticate(\n          resData.id_token,\n          resData.user_id,\n          parseInt(resData.expires_in) * 1000\n        )\n      );\n      // The first new Date converts the second's huge number of miliseconds in a concrete date.\n\n      const expirationDate = new Date(\n        new Date().getTime() + parseInt(resData.expires_in) * 1000\n      );\n\n      // For testing:\n      // const expirationDate = new Date(new Date().getTime() + 20 * 1000);\n      // console.log('resData refreshData', resData.refresh_token);\n\n      saveDataToStorage(\n        resData.id_token,\n        resData.user_id,\n        expirationDate,\n        resData.email,\n        resData.refresh_token\n      );\n    } catch (error) {\n      throw error;\n    }\n  };\n};\n\n//////////////////////////////////////////\n\nexport const changeEmail = (email: string) => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      // console.log(\"changeEmail\", email);\n      const token = getState().auth.token;\n      //   console.log(token);\n\n      const response = await fetch(\n        \"https://identitytoolkit.googleapis.com/v1/accounts:update?key=\" +\n        API_KEY,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            idToken: token,\n            email: email,\n            returnSecureToken: true,\n          }),\n        }\n      );\n      // console.log(response);\n\n      if (!response.ok) {\n        const errorResData = await response.json();\n        const errorId = errorResData.error.message;\n        let message = \"Σφάλμα κατά την διαδικασία σύνδεσης!\";\n        if (errorId === \"EMAIL_EXISTS\") {\n          message = \"Αυτή η ηλεκτρονική διεύθυνση ήδη υπάρχει!\";\n        } else if (errorId === \"INVALID_ID_TOKEN\") {\n          message =\n            \"Τεκμήριο άκυρο. Παρακαλώ αποσυνδεθείτε, μετά συνδεθείτε και δοκιμάστε ξανά.\";\n        }\n        throw new Error(message);\n      }\n      const resData = await response.json(); // transforms the data from json to javascript object\n\n      dispatch(\n        authenticate(\n          resData.idToken,\n          resData.localId,\n          parseInt(resData.expiresIn) * 1000,\n          email\n        )\n      );\n      // const expirationDate = new Date(new Date().getTime() + 20 * 1000);\n\n      // The first new Date converts the second's huge number of miliseconds in a concrete date.\n      const expirationDate = new Date(\n        new Date().getTime() + parseInt(resData.expiresIn) * 1000\n      );\n      saveDataToStorage(\n        resData.idToken,\n        resData.localId,\n        expirationDate,\n        resData.email,\n        resData.refreshToken\n      );\n    } catch (error) {\n      throw error;\n    }\n  };\n};\n\nexport const changePassword = (password: string) => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const token = getState().auth.token;\n\n      const response = await fetch(\n        \"https://identitytoolkit.googleapis.com/v1/accounts:update?key=\" +\n        API_KEY,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            idToken: token,\n            password: password,\n            returnSecureToken: true,\n          }),\n        }\n      );\n      console.log(response.ok);\n\n      if (!response.ok) {\n        const errorResData = await response.json();\n        const errorId = errorResData.error.message;\n        let message = \"Σφάλμα κατά την διαδικασία σύνδεσης!\";\n        if (errorId === \"INVALID_ID_TOKEN\") {\n          message =\n            \"Τεκμήριο άκυρο. Παρακαλώ αποσυνδεθείτε, μετά συνδεθείτε και δοκιμάστε ξανά. \";\n        } else if (errorId === \"WEAK_PASSWORD\") {\n          message = \"Ο κωδικός θα πρέπει να έχει τουλάχιστον 6 γράμματα! \";\n        }\n        throw new Error(message);\n      }\n      const resData = await response.json(); // transforms the data from json to javascript object\n\n      dispatch(\n        authenticate(\n          resData.idToken,\n          resData.localId,\n          parseInt(resData.expiresIn) * 1000\n        )\n      );\n      // const expirationDate = new Date(new Date().getTime() + 20 * 1000);\n\n      // The first new Date converts the second's huge number of miliseconds in a concrete date.\n      const expirationDate = new Date(\n        new Date().getTime() + parseInt(resData.expiresIn) * 1000\n      );\n      saveDataToStorage(\n        resData.idToken,\n        resData.localId,\n        expirationDate,\n        resData.email,\n        resData.refreshToken\n      );\n    } catch (error) {\n      throw error;\n    }\n  };\n};\n\nexport const changeUserName = (userName: string) => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const userId = getState().auth.userId;\n      const token = getState().auth.token;\n\n      // First check if there is already a userName in Database saved.\n      // Delete the old one and post the new one.\n      const fetchResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com//usersNames/${userId}.json`\n      );\n\n      if (!fetchResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του ονόματος χρήστη δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const fetchResponseResData = await fetchResponse.json();\n\n      if (!!fetchResponseResData) {\n        const deleteResponse = await fetch(\n          `https://en-touto-nika.firebaseio.com//usersNames/${userId}.json?auth=${token}`,\n          {\n            method: \"DELETE\",\n          }\n        );\n\n        if (!deleteResponse.ok) {\n          throw new Error(\n            \"Δυστυχώς η διαγραφή του προγηγούμενου ονόματος χρήστη δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n          );\n        }\n      }\n\n      // Save the userName to a user specific database\n      const saveImageUrlResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com//usersNames/${userId}.json?auth=${token}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({ userName }),\n        }\n      );\n\n      if (!saveImageUrlResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η αποθήκευση του ονόματος χρήστη δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n      // Get the userName on the screen.\n      await dispatch(fetchUserName());\n      const oldUserName = await localStorage.getItem(strings.userName);\n      if (!!oldUserName) {\n        await localStorage.removeItem(strings.userName);\n      }\n      await localStorage.setItem(strings.userName, userName);\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n\nexport const fetchUserName = () => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const userId = getState().auth.userId;\n      // const token = getState().auth.token;\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//usersNames/${userId}.json`\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του ονόματος χρήστη δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const resData = await response.json();\n\n      let userName = \"\";\n      for (const key in resData) {\n        userName = resData[key].userName;\n      }\n\n      const oldUserName = await localStorage.getItem(strings.userName);\n      if (!!oldUserName) {\n        await localStorage.removeItem(strings.userName);\n      }\n      await localStorage.setItem(strings.userName, JSON.stringify(userName));\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n\nexport const fetchAllUsersNames = () => {\n  return async (dispatch: Function) => {\n    try {\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//usersNames.json`\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του ονόματος χρήστη δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const resData = await response.json();\n\n      // console.log('fetchAllUsersProfilePictureUrls ', resData);\n\n      dispatch({\n        type: USERS_NAMES,\n        usersNames: resData,\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n\nexport const saveImage = (img: any, prevImg: any) => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const userId = getState().auth.userId;\n      const token = getState().auth.token;\n\n      // First check if there is already an imageUrl in Database saved.\n      // Delete the old one and post the new one.\n      const fetchResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com//profilePictures/${userId}.json`\n      );\n\n      if (!fetchResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του συνδέσμου της φωτογραφίας (imageUrl) δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const fetchResponseResData = await fetchResponse.json();\n\n      if (!!fetchResponseResData) {\n        const deleteResponse = await fetch(\n          `https://en-touto-nika.firebaseio.com//profilePictures/${userId}.json?auth=${token}`,\n          {\n            method: \"DELETE\",\n          }\n        );\n\n        if (!deleteResponse.ok) {\n          throw new Error(\n            \"Δυστυχώς η διαγραφή της προηγούμενης εικόνας προφίλ δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n          );\n        }\n      }\n\n      // if (!!prevImg) {\n      //   await firebase.deletePreviousImage(prevImg, userId);\n      // }\n\n      // let imageUrl = null;\n      // if (!!img) {\n      //   imageUrl = await firebase.storeImage(img, userId);\n      // }\n\n      // Save the imageUrl to a user specific database\n      const saveImageUrlResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com//profilePictures/${userId}.json?auth=${token}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            imageUrl: img.uri,\n          }),\n        }\n      );\n\n      if (!saveImageUrlResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η αποθήκευση του συνδέσμου της φωτογραφίας (imageUrl) δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n      // Get the image on the screen.\n      await dispatch(fetchUserProfilePictureUrl());\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n\nexport const fetchUserProfilePictureUrl = () => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const userId = getState().auth.userId;\n      // const token = getState().auth.token;\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//profilePictures/${userId}.json`\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του συνδέσμου της φωτογραφίας (imageUrl) δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const resData = await response.json();\n\n      let imageUrl = \"\";\n      for (const key in resData) {\n        imageUrl = resData[key].imageUrl;\n      }\n\n      dispatch({\n        type: USER_PROFILE_PICTURE_URL,\n        userProfilePictureUrl: imageUrl,\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n\nexport const fetchAllUsersProfilePictureUrls = () => {\n  return async (dispatch: Function) => {\n    try {\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//profilePictures.json`\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η εύρεση του συνδέσμου της φωτογραφίας (imageUrl) δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const resData = await response.json();\n\n      // console.log('fetchAllUsersProfilePictureUrls ', resData);\n\n      dispatch({\n        type: USERS_PROFILE_PICTURE_URLS,\n        usersProfilePictureUrls: resData,\n      });\n    } catch (err) {\n      console.log(err);\n    }\n  };\n};\n","import {\n  AUTHENTICATE,\n  LOG_OUT,\n  USER_PROFILE_PICTURE_URL,\n  USERS_PROFILE_PICTURE_URLS,\n  USERS_NAMES,\n  TRIED_AUTOLOGIN,\n  ALLOW_ENTRANCE,\n  SET_SKIP_INTRO_SCREEN,\n  FORGOT_PASSWORD,\n} from \"../actions/auth\";\n\nconst initialState = {\n  allowEntrance: false,\n  email: \"\",\n  forgotPassword: false,\n  token: '',\n  triedAutoLogin: false,\n  userId: '',\n  userProfilePictureUrl: '',\n  usersNames: '',\n  usersProfilePictureUrls: '',\n};\n\n\nconst auth = (state = initialState, action: {\n  allowEntrance?: boolean,\n  email?: string,\n  forgotPassword?: boolean,\n  set?: boolean,\n  token?: string,\n  triedAutoLogin?: boolean,\n  type: string,\n  userEmail?: string,\n  userId?: string,\n  userProfilePictureUrl?: string\n  usersNames?: Array<string>,\n  usersProfilePictureUrls?: string,\n}) => {\n  switch (action.type) {\n    case AUTHENTICATE:\n      return {\n        ...state,\n        token: action.token,\n        userId: action.userId,\n        email: action.userEmail,\n        triedAutoLogin: true,\n      };\n    case TRIED_AUTOLOGIN:\n      return {\n        ...state,\n        triedAutoLogin: action.set,\n      };\n    case ALLOW_ENTRANCE:\n      return {\n        ...state,\n        allowEntrance: action.set,\n      };\n    case SET_SKIP_INTRO_SCREEN:\n      return {\n        ...state,\n        skipIntroScreen: action.set,\n      };\n    case FORGOT_PASSWORD:\n      return {\n        ...state,\n        forgotPassword: action.set,\n      };\n    case LOG_OUT:\n      return {\n        ...state,\n        token: null,\n        userId: null,\n        triedAutoLogin: false,\n      };\n    case USER_PROFILE_PICTURE_URL:\n      return {\n        ...state,\n        userProfilePictureUrl: action.userProfilePictureUrl,\n      };\n    case USERS_PROFILE_PICTURE_URLS:\n      return {\n        ...state,\n        usersProfilePictureUrls: action.usersProfilePictureUrls,\n      };\n    case USERS_NAMES:\n      return {\n        ...state,\n        usersNames: action.usersNames,\n      };\n    default:\n      return state;\n  }\n};\n\nexport default auth;","\nconst set = async (key: string, value: any) => {\n  try {\n    await localStorage.setItem(key, JSON.stringify(value));\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst get = async (key: string) => {\n  try {\n    const value = await localStorage.getItem(key);\n    if (!!value) {\n      const item = JSON.parse(value);\n      if (item == null) return null;\n      return item;\n    }\n\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst remove = async (key: string) => {\n  try {\n    await localStorage.removeItem(key);\n  } catch (error) {\n    console.log(error);\n  }\n};\n\nconst cache = {\n  set,\n  get,\n  remove,\n};\n\nexport default cache;","import strings from \"../../../constants/strings\";\nimport cache from \"../../../utils/cache\";\n\nexport const FETCH_All_USERS_DATA = \"FETCH_All_USERS_DATA\";\n\nexport const saveDataToAllUsersData = (email: string, totalPoints: number) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n      const date = new Date();\n\n      // Fist post the data\n      const firstPostResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com//All_Users_Data/${userId}.json?auth=${token}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            totalPoints,\n            email,\n            date: date.toISOString()\n          })\n        }\n      );\n\n      if (!firstPostResponse.ok) {\n        alert(\n          \"Δυστυχώς η ανάκτηση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n\n        throw new Error(\n          \"Δυστυχώς η ανάκτηση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n\n      }\n\n    } catch (err) {\n      // send to custom analytics server\n      alert(\n        \"Προκειμένου κατεβάσετε τα δεδομένα όλων των παικτών, θα πρέπει να είστε συνδεδεμένοι στο ίντερνετ. Παρακαλώ ελέγξτε την σύνδεσή σας.\"\n      );\n      throw err;\n    }\n  };\n};\n\nexport const fetchAllUsersData = () => {\n  return async (dispatch: Function) => {\n    try {\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//All_Users_Data.json`\n      );\n\n      // check before unpack the response body\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των δεδομένων για όλους τους παίκτες δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n      const resData = await response.json();\n\n      dispatch({\n        type: FETCH_All_USERS_DATA,\n        allUsersData: resData\n      });\n    } catch (err) {\n      // send to custom analytics server\n      alert(\n        \"Προκειμένου κατεβάσετε τα δεδομένα όλων των παικτών, θα πρέπει να είστε συνδεδεμένοι στο ίντερνετ. Παρακαλώ ελέγξτε την σύνδεσή σας.\"\n      );\n\n      throw err;\n    }\n  };\n};\n","import { FETCH_All_USERS_DATA } from \"../actions/data/mixedData\";\n\nconst initialState = {\n  allUsersData: {}\n};\n\nconst data = (state = initialState, action: { type: string, allUsersData: object }) => {\n  switch (action.type) {\n    case FETCH_All_USERS_DATA:\n      return {\n        ...state,\n        allUsersData: action.allUsersData\n      };\n\n    default:\n      return state; // is actually first reached when app starts\n  }\n};\n\nexport default data;\n","import strings from \"../../constants/strings\";\n// import cache from \"../../utils/cache\";\nimport { store } from \"../configureStore\";\n\nexport const UPLOAD_CATEGORIES_FILTERS = \"UPLOAD_CATEGORIES_FILTERS\";\nexport const DELETE_PREVIOUS_CATEGORIES_FILTERS =\n  \"DELETE_PREVIOUS_CATEGORIES_FILTERS\";\nexport const FETCH_CATEGORIES_FILTERS = \"FETCH_CATEGORIES_FILTERS\";\n\nexport interface AppliedFilters {\n  one: boolean,\n  two: boolean,\n  three: boolean,\n  four: boolean,\n  filtersAreApplied: boolean,\n};\n\nexport const uploadCategoriesFilters = (gameType: string, appliedCategoriesFilters: AppliedFilters) => {\n  return async (dispatch: Function) => {\n    try {\n\n      const { userId, token } = store.getState().auth;\n\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com//categoriesFilters${gameType}/${userId}.json?auth=${token}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            appliedCategoriesFilters,\n          }),\n        }\n      );\n\n      // Set the filters to get them in ApanthismaScreen to initialize\n      // Categories with previous chosen - saved filters.\n      await localStorage.setItem(\n        strings.categoriesFilters,\n        JSON.stringify({\n          appliedCategoriesFilters,\n        })\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η αποθήκευση των κατηγοριών δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n      dispatch({\n        type: UPLOAD_CATEGORIES_FILTERS,\n        appliedCategoriesFilters: appliedCategoriesFilters,\n      });\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deletePreviousCategoriesFilters = (gameType: string) => {\n  return async (dispatch: Function) => {\n    try {\n      const { userId, token } = store.getState().auth;\n\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com/categoriesFilters${gameType}/${userId}.json?auth=${token}`,\n        {\n          method: \"DELETE\",\n        }\n      );\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η αλλαγή της κατάστασης της κατηγορίας δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      // This action is not need!\n      dispatch({ type: DELETE_PREVIOUS_CATEGORIES_FILTERS });\n    } catch (err) {\n      // send to custom analytics server\n      console.log(err);\n      throw err;\n    }\n  };\n};\n\nexport const fetchCategoriesFilters = (gameType: string) => {\n  return async (dispatch: Function) => {\n    try {\n      const { userId } = store.getState().auth;\n\n      const filtersResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com/categoriesFilters${gameType}/${userId}.json`\n      );\n\n      // check before unpack the filtersResponse body\n      if (!filtersResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση της κατάστασης των κατηγοριών δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const filtersResData = await filtersResponse.json();\n\n      let appliedCategoriesFilters = [];\n      if (!!filtersResData) {\n        for (const key in filtersResData) {\n          appliedCategoriesFilters =\n            filtersResData[key].appliedCategoriesFilters;\n        }\n      }\n      await localStorage.setItem(\n        strings.categoriesFilters,\n        JSON.stringify({ appliedCategoriesFilters })\n      );\n\n      dispatch({\n        type: FETCH_CATEGORIES_FILTERS,\n        appliedCategoriesFilters: appliedCategoriesFilters,\n      });\n    } catch (err) {\n      // send to custom analytics server\n      console.log(err);\n      alert(\"Δυστυχώς η φόρτωση της κατάστασης των κατηγοριών δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\");\n\n      throw err;\n    }\n  };\n};\n","import {\n  FETCH_CATEGORIES_FILTERS,\n  DELETE_PREVIOUS_CATEGORIES_FILTERS,\n  UPLOAD_CATEGORIES_FILTERS\n} from \"../actions/filters\";\n\nimport { AppliedFilters } from '../actions/filters';\n\nconst initialState = {\n  categoriesFilters: {}\n};\n\nconst filters = (state = initialState, action: { type: string, appliedCategoriesFilters: AppliedFilters }) => {\n  switch (action.type) {\n    case UPLOAD_CATEGORIES_FILTERS:\n      return {\n        ...state,\n        categoriesFilters: action.appliedCategoriesFilters\n      };\n\n    case FETCH_CATEGORIES_FILTERS:\n      return {\n        ...state,\n        categoriesFilters: action.appliedCategoriesFilters\n      };\n\n    case DELETE_PREVIOUS_CATEGORIES_FILTERS:\n      return {\n        ...state,\n        categoriesFilters: {}\n      };\n    default:\n      return state; // is actually first reached when app starts\n  }\n};\n\nexport default filters;\n","export const LOGIN_MODE = 'LOGIN_MODE';\nexport const TIMER_STATE = 'TIMER_STATE';\nexport const GAME_STATE = 'GAME_STATE';\nexport const GAME_TYPE_TITLE = 'GAME_TYPE_TITLE';\nexport const GAME_ON = 'GAME_ON';\nexport const SAVE_POINTS = 'SAVE_POINTS';\nexport const SAVE_POINTS_TYPE = 'SAVE_POINTS_TYPE';\n\nexport const loginMode = (mode: boolean) => {\n  return {\n    type: LOGIN_MODE,\n    mode\n  }\n}\n\nexport const timerState = (timer: boolean,) => {\n  return {\n    type: TIMER_STATE,\n    timer,\n  }\n}\n\nexport const gameState = (id: string, title: string) => {\n  return {\n    type: GAME_STATE,\n    id,\n    title\n  }\n}\n\nexport const gameTypeTitle = (title: string) => {\n  return {\n    type: GAME_TYPE_TITLE,\n    title\n  }\n}\n\nexport const gameOn = (gameOn: boolean) => {\n  return {\n    type: GAME_ON,\n    gameOn\n  }\n}\n\nexport const savePoints = (points: number, pointsType: string) => {\n  return {\n    type: SAVE_POINTS,\n    points,\n    pointsType\n  }\n}\n\nexport const savePointsType = (pointsType: string) => {\n  return {\n    type: SAVE_POINTS_TYPE,\n    pointsType\n  }\n}\n\n\n","import strings from '../../constants/strings';\nimport { LOGIN_MODE, GAME_STATE, TIMER_STATE, GAME_TYPE_TITLE, GAME_ON, SAVE_POINTS, SAVE_POINTS_TYPE } from '../actions/game';\ninterface Action {\n  type: string,\n  mode: boolean,\n  timer: boolean\n  title: string,\n  gameTypeTitle: string,\n  id: string,\n  gameOn: boolean,\n  points: number,\n  pointsType: string,\n}\n\nconst initialState = {\n  mode: true,\n  timer: false,\n  title: '',\n  gameTypeTitle: '',\n  id: '',\n  gameOn: false,\n  pointsMultiMixed: 0,\n  pointsTrueFalseMixed: 0,\n  pointsType: '',\n}\n\nconst game = (state = initialState, action: Action) => {\n  switch (action.type) {\n    case LOGIN_MODE:\n      return {\n        ...state,\n        mode: action.mode\n      }\n    case TIMER_STATE:\n      return {\n        ...state,\n        timer: action.timer,\n      }\n    case GAME_STATE:\n      return {\n        ...state,\n        id: action.id,\n        title: action.title\n      }\n    case GAME_TYPE_TITLE:\n      return {\n        ...state,\n        gameTypeTitle: action.title\n      }\n    case GAME_ON:\n      return {\n        ...state,\n        gameOn: action.gameOn\n      }\n    case SAVE_POINTS:\n      if (action.pointsType === strings.pointsTypeMultiMixed) {\n        return {\n          ...state,\n          pointsMultiMixed: action.points,\n          pointsType: strings.pointsTypeMultiMixed\n        }\n      }\n      if (action.pointsType === strings.pointsTypeTrueFalseMixed) {\n        return {\n          ...state,\n          pointsTrueFalseMixed: action.points,\n          pointsType: strings.pointsTypeTrueFalseMixed\n        }\n      }\n      return { ...state }\n    case SAVE_POINTS_TYPE:\n      return {\n        ...state,\n        pointsType: action.pointsType\n      }\n\n    default:\n      return state;\n  }\n}\n\nexport default game;","import { createStore, combineReducers, compose, applyMiddleware } from \"redux\";\nimport thunk from \"redux-thunk\";\nimport { persistStore, persistReducer } from 'redux-persist'\nimport storage from 'redux-persist/lib/storage' // defaults to localStorage for web\n\nimport AuthReducer from \"./reducers/auth\";\nimport DataReducer from \"./reducers/data\";\nimport FiltersReducer from \"./reducers/filters\";\nimport GeneralReducer from \"./reducers/game\";\nimport { LOG_OUT } from \"./actions/auth\";\n\nconst appReducer = combineReducers({\n  auth: AuthReducer,\n  data: DataReducer,\n  fliters: FiltersReducer,\n  game: GeneralReducer\n});\n\nconst rootReducer = (state: any, action: any) => {\n  if (action.type === LOG_OUT) {\n    storage.removeItem('persist:root');\n    return appReducer(undefined, action);\n  }\n  return appReducer(state, action)\n}\n\nconst persistConfig = {\n  key: 'root',\n  storage,\n}\n\nconst persistedReducer = persistReducer(persistConfig, rootReducer);\n\n\nconst configureStore = () => {\n  let store = createStore(persistedReducer, composeEnhancers(applyMiddleware(thunk)));\n  let persistor = persistStore(store)\n  return { store, persistor }\n};\n\n\ndeclare global {\n  interface Window {\n    __REDUX_DEVTOOLS_EXTENSION_COMPOSE__?: typeof compose;\n  }\n}\n\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n\nexport const { store, persistor } = configureStore();\n\nexport default configureStore;\n","\nconst nav = {\n  home: '/',\n  winners: \"/winners\",\n  settings: \"/settings\",\n  create: \"/create\",\n  auth: '/auth',\n  donate: '/donate',\n  not_found: '/not-found',\n  multiCategories: \"/multi-categories\",\n  multiCategoriesNoTimer: \"/multi-categories-no-timer\",\n  multiGameNoTimer: \"/multi-game-no-timer\",\n  multiGameWithTimer: \"/multi-game-with-timer\",\n  trueFalseCategories: \"/true-false-categories\",\n  trueFalseCategoriesNoTimer: \"/true-false-categories-no-timer\",\n  trueFalseGameNoTimer: \"/true-false-game-no-timer\",\n  trueFalseGameWithTimer: \"/true-false-game-with-timer\",\n\n  trueFalseMixedGameNoTimer: \"/true-false-fixed-game-no-timer\",\n\n  mixGameIsOn: '/mix-game-is-on',\n  mixChooseCategories: \"/mix-choose-categories\",\n  mixMultiGameWithTimer: \"/mixed-multi-game-with-timer\",\n  mixMultiGameNoTimer: \"/mixed-multi-game-no-timer\",\n  mixTrueFalseGameWithTimer: \"/mixed-true-false-game-with-timer\",\n  mixTrueFalseGameNoTimer: \"/mixed-true-false-game-no-timer\",\n\n  createHome: 'create-home',\n  createMultiCategories: \"CreateMultiCategories\",\n  createNavigator: \"CreateNavigator\",\n  createMultiOverview: \"CreateMultiOverview\",\n  createTrueFalse: \"CreateTrueFalse\",\n  createTrueFalseCategories: \"CreateTrueFalseCategories\",\n  createTrueFalseOverview: \"CreateTrueFalseOverview\",\n  editMultiQuestion: \"EditMultiQuestion\",\n  editTrueFalseQuestion: \"EditTrueFalseQuestion\",\n  forgotPassword: \"ForgotPassword\",\n  gameInfo: \"GameInfo\",\n  gameInfoNavigator: \"GameInfoNavigator\",\n  gameNavigator: \"GameNavigator\",\n  intro: \"Intro\",\n\n\n\n\n};\n\nexport default nav;","import { NavLink } from \"react-router-dom\";\nimport { FaHome } from 'react-icons/fa'\nimport { AiFillSetting } from 'react-icons/ai'\nimport { GiPodiumWinner } from 'react-icons/gi'\nimport { BiLogOut, BiLogIn, BiDonateBlood } from 'react-icons/bi'\nimport { IoIosCreate } from 'react-icons/io'\n\nimport strings from '../../constants/strings'\nimport nav from '../../constants/nav'\nimport '../../styles/menu/menu.css';\nimport { useDispatch } from \"react-redux\";\nimport { logout } from \"../../store/actions/auth\";\n\n\nexport default function Menu({ menuOpen, setMenuOpen }: { menuOpen: boolean, setMenuOpen: Function }) {\n  const dispatch = useDispatch()\n  const userIsLoggedIn = !!localStorage.getItem(strings.userData);\n\n  const menuHandler = () => {\n    setMenuOpen(false);\n  };\n\n  const logoutHandler = () => {\n    // setMenuOpen(false);\n    dispatch(logout())\n  };\n\n  return (\n    <div className={`menu ${menuOpen ? \"active\" : ''}`}>\n      <h1>ΕΝ ΤΟΥΤΩ ΝΙΚΑ</h1>\n      <ul>\n        <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.home}>\n            <FaHome className='menu-icon' /> <p> Αρχική </p>\n          </NavLink>\n        </li>\n        <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.winners}>\n            <GiPodiumWinner className='menu-icon' /> <p> Νικητές </p>\n          </NavLink>\n        </li>\n        <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.settings}>\n            <AiFillSetting className='menu-icon' /> <p>Ρυθμίσεις</p>\n          </NavLink>\n        </li>\n        <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.create}>\n            <IoIosCreate className='menu-icon' /> <p>Δημιουργία</p>\n          </NavLink>\n        </li>\n        <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.donate}>\n            <BiDonateBlood className='menu-icon' /> <p>Δωρεά</p>\n          </NavLink>\n        </li>\n        {userIsLoggedIn ? <li>\n          <NavLink className='link' onClick={logoutHandler} to={nav.auth}>\n            <BiLogOut className='menu-icon' /> <p>Έξοδος</p>\n          </NavLink>\n        </li> : null}\n        {!userIsLoggedIn ? <li>\n          <NavLink className='link' onClick={menuHandler} to={nav.auth}>\n            <BiLogIn className='menu-icon' /> <p>Είσοδος</p>\n          </NavLink>\n        </li> : null}\n      </ul>\n    </div>\n  );\n};\n\n","export default class IconCard {\n  id: string;\n  title: string;\n\n  constructor(id: string, title: string) {\n    this.id = id;\n    this.title = title;\n  }\n}\n","import IconCard from \"../models/icon-card\";\n\nconst GAME_TYPES = [\n  new IconCard(\"Multi\", \"Πολλαπλών Επιλογών\"),\n  new IconCard(\"TrueFalse\", \"Σωστό / Λάθος\"),\n];\n\nexport default GAME_TYPES","import React from \"react\";\n\nimport '../../styles/grid-items/grid-item-home.css';\n// const jesus = require(\"../../../assets/jesus-categories.jpg\");\nconst theotokos = \"assets/glykofilousa-categories.jpg\";\nconst john = \"assets/john-for-categories.jpg\";\n\nconst GridItemHome = (props: any) => { //{ id, playHandler, style, title }\n  let image = null;\n  switch (props.id) {\n    case \"Multi\":\n      image = theotokos;\n      break;\n    case \"TrueFalse\":\n      image = john;\n      break;\n    default:\n      image = theotokos;\n      break;\n  }\n\n\n\n\n  return (\n    <li onClick={props.onClick} className='home-grid-list-item' >\n      <div className=\"home-grid-icon-container\">\n        <img src={image} alt=\"grid item icon\" />\n      </div>\n      <p className='home-grid-title' >{props.title}</p>\n    </li >\n  );\n};\n\nexport default GridItemHome;\n","\nimport '../../styles/UI/loader.css';\n\nexport default function Loader() {\n  return (\n    <div className='loader'>\n      <div className='loader__element' ></div>\n    </div>\n  )\n}\n","import * as authActions from \"../store/actions/auth\";\nimport strings from '../constants/strings';\nimport { store } from \"../store/configureStore\";\n\nconst tryLogin = async (setError: Function) => {\n  try {\n    const userData = await localStorage.getItem(strings.userData);\n\n    if (!userData) {\n      store.dispatch(authActions.triedAutoLogin(true));\n      return;\n    }\n\n    const transformedData = JSON.parse(userData);\n    const { token, userId, userEmail, expiryDate } = transformedData;\n    const expirationDate = new Date(expiryDate); // expiryDate is string in ISO format...\n    // console.log(\"user ID\", userId);\n\n    if (expirationDate <= new Date() || !token || !userId) {\n      // if (true) {\n      const refreshToken = await localStorage.getItem(strings.refreshToken);\n      if (!!refreshToken)\n        store.dispatch(authActions.refreshData(refreshToken));\n    } else {\n      store.dispatch(\n        authActions.authenticate(token, userId, expiryDate, userEmail)\n      );\n    }\n  } catch (err) {\n    setError(err.message);\n  }\n};\n\nexport default tryLogin;","import { useEffect, useState } from 'react';\n\nimport GAME_TYPES from '../data/game-types';\n\nimport GridItemHome from '../components/grid-items/GridItemHome';\nimport '../styles/home.css';\nimport { RootStateOrAny, useDispatch, useSelector } from 'react-redux';\nimport { useHistory } from 'react-router-dom';\nimport nav from '../constants/nav';\nimport { gameOn, gameState, gameTypeTitle, savePointsType } from '../store/actions/game';\n\nimport Loader from '../components/UI/Loader';\nimport tryLogin from '../utils/tryLogin';\n\ninterface Item {\n  id: string,\n  title: string\n}\n\nexport default function Home(props: any) {\n  const dispatch = useDispatch();\n  const history = useHistory();\n\n  const [error, setError] = useState(); // error initially is undefined!\n\n\n  const timer = useSelector((state: RootStateOrAny) => state.game.timer);\n  const triedAutoLogin = useSelector((state: RootStateOrAny) => state.auth.triedAutoLogin)\n  const isAuth = useSelector((state: RootStateOrAny) => state.auth.token)\n\n  useEffect(() => {\n    dispatch(gameTypeTitle(''))\n    dispatch(gameOn(false)); // to reveal the Topbar\n    dispatch(savePointsType(''))\n\n  }, [dispatch])\n\n  useEffect(() => {\n    // tryLogin checks if users token is valid\n    // and if not it gets a new one\n    tryLogin(setError);\n  }, []);\n\n  const playHandler = async (item: Item) => {\n    if (timer) {\n      if (item.id === \"Multi\") {\n        await dispatch(gameState(item.id, item.title));\n        history.push(nav.multiCategories);\n      } else if (item.id === \"TrueFalse\") {\n        await dispatch(gameState(item.id, item.title));\n        history.push(nav.trueFalseCategories);\n      }\n    } else {\n      if (item.id === \"Multi\") {\n        await dispatch(gameState(item.id, item.title));\n        history.push(nav.multiCategoriesNoTimer);\n      } else if (item.id === \"TrueFalse\") {\n        await dispatch(gameState(item.id, item.title));\n        history.push(nav.trueFalseCategoriesNoTimer);\n      }\n    }\n  };\n\n  if (error) {\n    return (\n      <div>\n        <div >\n          <h3>\n            Σφάλμα στη διαδικασία εκκινήσεως του παιχνιδιού. Παρακαλούμε ελέγξτε\n            τη σύνδεσή σας.\n          </h3>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className='home'>\n      {!triedAutoLogin || !isAuth ?\n        <div className='home-loader' >\n          <Loader />\n        </div>\n        : null}\n      <ul className='home__list' >\n        {GAME_TYPES.map((game: { id: string, title: string }) =>\n          <GridItemHome\n            key={game.id}\n            id={game.id}\n            title={game.title}\n            onClick={playHandler.bind(null, game)}\n          />\n        )}\n      </ul>\n    </div>\n  )\n}\n","import React from 'react'\n\nexport default function Winners() {\n  return (\n    <div>\n      Winners\n    </div>\n  )\n}\n","import React from 'react'\n\nexport default function Settings() {\n  return (\n    <div>\n      Settings\n    </div>\n  )\n}\n","import React from 'react'\n\nexport default function Create() {\n  return (\n    <div>\n      Create\n    </div>\n  )\n}\n","import React from 'react'\n\nexport default function NotFound() {\n  return (\n    <div>\n\n    </div>\n  )\n}\n","import '../../styles/UI/theotokos-icon.css';\nimport { RootStateOrAny, useSelector } from 'react-redux';\n\nconst TheotokosIcon = (props: any) => {\n  const login = useSelector((state: RootStateOrAny) => state.game.mode);\n\n  return (\n    <div className={`theotokos-icon ${!login && \"theotokos-icon--small\"} `} >\n      <img src=\"assets/panagia-glykofilousa.jpg\" alt=\"theotokos\" />\n    </div >\n  );\n};\n\nexport default TheotokosIcon;\n","import '../../styles/UI/button.css'\n\nconst Button = (props: any) => {\n  return (\n    <button\n      className={`${props.disabled ? 'button-disabled' : ''}`}\n      style={props.style}\n      onClick={props.onClick}\n      onMouseEnter={props.onMouseLeave}\n      onMouseLeave={props.onMouseLeave}\n      disabled={props.disabled}\n    >\n      {props.title}\n    </button>\n  );\n};\n\nexport default Button\n  ;\n\n","import \"../../styles/UI/input.css\";\n\nconst Input = (props: any) =>\n  <div className='input__container' >\n    <input\n      name={props.name}\n      value={props.value}\n      onChange={props.onChange}\n      onBlur={props.onBlur}\n      type={props.type}\n      placeholder={props.placeholder}\n      autoFocus={props.autoFocus}\n    />\n    <p className=\"input__error\">{props.error}</p>\n  </div>\n\n\nexport default Input;\n","\nlet errors = {\n  login: '',\n  auth: '',\n  name: '',\n  email: '',\n  password: '',\n  confirmPassword: '',\n};\n\nexport const loginFormIsValid = (email: string, password: string, setErrors: Function) => {\n  if (!email.trim().length || !password.trim().length) {\n    errors = { ...errors, login: \"Συμπληρώστε όλα τα πεδία!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, login: \"\" };\n    setErrors(errors);\n  }\n  return true;\n}\n\nexport const authFormIsValid = (name: string, email: string, password: string, confirmPassword: string, setErrors: Function) => {\n  if (!name.trim().length || !email.trim().length || !password.trim().length || !confirmPassword.trim().length) {\n    errors = { ...errors, auth: \"Συμπληρώστε όλα τα πεδία!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, auth: \"\" };\n    setErrors(errors);\n  }\n  return true;\n};\n\nexport const nameIsValid = (name: string, setErrors: Function) => {\n  if (name.trim().length <= 1) {\n    errors = { ...errors, name: \"Τουλάχιστον 2 γράμματα!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, name: \"\" };\n    setErrors(errors);\n  }\n  return true;\n\n}\n\nexport const emailIsValid = (email: string, setErrors: Function) => {\n  const emailRegex = /^(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\n  console.log('emailIsValid');\n\n  if (!emailRegex.test(email.trim().toLowerCase())) {\n    errors = { ...errors, email: \"...δεν είναι έγκυρη!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, email: \"\" };\n    setErrors(errors);\n  }\n  return true;\n}\n\nexport const passwordIsValid = (password: string, setErrors: Function) => {\n  if (password.trim().length < 6 || password.trim().length > 12) {\n    errors = { ...errors, password: \"Απο 6 μέχρι 12 γράμματα!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, password: \"\" };\n    setErrors(errors);\n  }\n  return true;\n};\n\nexport const passwordNoMatch = (password: string, confirmPassword: string, setErrors: Function) => {\n  if (password.trim() !== confirmPassword.trim()) {\n    errors = { ...errors, password: \"Κωδικοί πρόσβασης δεν ταιριάζουν!\" };\n    setErrors(errors);\n    return false;\n  } else {\n    errors = { ...errors, password: \"\" };\n    setErrors(errors);\n  }\n  return true;\n}\n\nexport const formIsValid = (setErrors: Function, login: boolean, name: string, email: string, password: string, confirmPassword: string) => {\n  if (login) {\n    if (!loginFormIsValid(email, password, setErrors)) {\n      return false;\n    }\n    if (!emailIsValid(email, setErrors)) {\n      return false;\n    }\n\n    if (!passwordIsValid(password, setErrors)) {\n      return false;\n    }\n  } else {\n    if (!authFormIsValid(name, email, password, confirmPassword, setErrors)) {\n      return false;\n    }\n    if (!nameIsValid(name, setErrors)) {\n      return false;\n    }\n\n    if (!emailIsValid(email, setErrors)) {\n      return false;\n    }\n\n    if (!passwordIsValid(password, setErrors)) {\n      return false;\n    }\n\n    if (!passwordNoMatch(password, confirmPassword, setErrors)) {\n      return false;\n    }\n  }\n  return true;\n};","import React, { useEffect, useCallback, useState } from 'react';\nimport { useDispatch } from \"react-redux\";\nimport { useHistory } from 'react-router-dom';\n\nimport colors from '../../constants/colors';\nimport '../../styles/UI/auth-card.css';\nimport Button from './Button';\nimport Input from './Input';\n\nimport { loginMode } from '../../store/actions/game';\nimport * as authActions from \"../../store/actions/auth\";\nimport Loader from './Loader';\nimport { emailIsValid, formIsValid, nameIsValid, passwordIsValid, passwordNoMatch } from '../../utils/auth-validation';\n\ninterface Errors {\n  login: string,\n  auth: string,\n  name: string,\n  email: string,\n  password: string,\n  confirmPassword: string,\n}\n\nconst errorsInitialState = {\n  login: '',\n  auth: '',\n  name: '',\n  email: '',\n  password: '',\n  confirmPassword: '',\n}\n\n// styles\nconst noSubEnterButton = {\n  height: 50,\n  fontSize: 20,\n  borderRadius: '35px',\n  boxShadow: `1px 1px 8px 3px ${colors.moccasin_light} `,\n  border: `1px solid ${colors.moccasin_light} `\n}\n\nconst AuthCard = (props: any) => {\n  const dispatch = useDispatch();\n  const history = useHistory()\n\n  const [hover, setHover] = useState(false);\n  const [login, setLogin] = useState(true);\n  const [name, setName] = useState<string>('');\n  const [email, setEmail] = useState<string>('');\n  const [password, setPassword] = useState<string>('');\n  const [confirmPassword, setConfirmPassword] = useState<string>('');\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [errors, setErrors] = useState<Errors>(errorsInitialState);\n\n  useEffect(() => {\n    (async () => { await dispatch(loginMode(login)) })()\n  }, [login, dispatch]);\n\n  const handleHover = () => {\n    setHover(!hover)\n  }\n\n  const handleLogin = () => {\n    setLogin(!login)\n  }\n\n  const freeEntranceHandler = () => {\n    dispatch(authActions.allowEntrance(true));\n    history.push('/')\n  }\n\n\n  const handleChange = (event: React.SyntheticEvent): void => {\n    const target = event.target as HTMLInputElement;\n    switch (target.name) {\n      case 'name':\n        setName(target.value);\n        nameIsValid(name, setErrors);\n        break;\n      case 'email':\n        setEmail(target.value);\n        emailIsValid(email, setErrors);\n        break;\n      case 'password':\n        setPassword(target.value);\n        passwordIsValid(password, setErrors);\n        break;\n      case 'confirmPassword':\n        setConfirmPassword(target.value)\n        passwordNoMatch(password, confirmPassword, setErrors);\n        break;\n      default:\n        break;\n    }\n  };\n\n\n\n  const handleSubmit = useCallback(async (event: React.SyntheticEvent) => {\n    event.preventDefault();\n    let action;\n    if (formIsValid(setErrors, login, name, email, password, confirmPassword)) {\n      if (login) {\n        action = authActions.login(email, password);\n      } else {\n        action = authActions.signup(email, password);\n      }\n      setIsLoading(true);\n      try {\n        await dispatch(action);\n        if (!login) {\n          await dispatch(authActions.changeUserName(name));\n          await dispatch(authActions.fetchUserName());\n        }\n        setName('');\n        setEmail('');\n        setPassword('');\n        setConfirmPassword('');\n        setErrors(errorsInitialState);\n        setIsLoading(false);\n        history.replace('/');\n      } catch (err) {\n        setIsLoading(false);\n        console.log(err);\n\n        //Note: only if we have an error we stay in this screen...\n      }\n    }\n  }, [name, email, password, confirmPassword, login, history, dispatch]);\n\n  const onBlur = () => {\n    // This check prevents getting error message\n    // on email input, if user's first click is outside.\n    if (nameIsValid(name, setErrors)) {\n      nameIsValid(name, setErrors);\n      emailIsValid(email, setErrors);\n      passwordIsValid(password, setErrors);\n      passwordNoMatch(password, confirmPassword, setErrors);\n    }\n  }\n\n  // style\n  const goToLoginButtom = {\n    width: '30%',\n    color: hover ? colors.maroon : colors.moccasin_light,\n    backgroundColor: !hover ? colors.chocolate : colors.moccasin_light,\n  }\n  return (\n    <section className='card' style={{ ...props.style }}>\n      <div className='card__container' >\n        <div className={`no-sub-enter-button ${login && 'no-sub-enter-button--login'}`} >\n          <Button\n            disabled={false}\n            title='Είσοδος χωρίς εγγραφή'\n            onClick={freeEntranceHandler}\n            style={noSubEnterButton} />\n        </div>\n        <form className={`${login && 'login-form'}`} >\n          {!login &&\n            <Input\n              name=\"name\"\n              value={name}\n              onChange={handleChange}\n              onBlur={onBlur}\n              error={errors.auth || errors.name}\n              type='text' placeholder='Όνομα παίκτη'\n              autoFocus={true}\n            />\n          }\n          <Input\n            name=\"email\"\n            value={email}\n            onChange={handleChange}\n            onBlur={onBlur}\n            error={errors.auth || errors.login || errors.email}\n            type='email'\n            placeholder='Ηλεκτρονική διεύθυνση'\n          />\n          <Input\n            name=\"password\"\n            value={password}\n            onChange={handleChange}\n            onBlur={onBlur}\n            error={errors.auth || errors.login || errors.password}\n            type='password' placeholder='Κωδικός πρόσβασης' />\n          {!login &&\n            <Input\n              name=\"confirmPassword\"\n              value={confirmPassword}\n              onChange={handleChange}\n              onBlur={onBlur}\n              error={errors.auth || errors.password}\n              type='password'\n              placeholder='Eπιβεβαίωση κωδικού' />\n          }\n          {isLoading ?\n            <Loader /> :\n            <Button disabled={false} title={!login ? 'Εγγραφή' : 'Είσοδος'} onClick={handleSubmit} style={{ width: '40%', }} />}\n\n        </form>\n        <div className=\"bottom-container\">\n          <p className='question' >{!login ? 'Έχετε λογαρισμό?' : 'Δεν έχετε λογαριασμό?'}</p>\n          <Button\n            disabled={false}\n            title={login ? 'Εγγραφή' : 'Είσοδος'}\n            onClick={handleLogin}\n            style={goToLoginButtom}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n        </div>\n      </div>\n    </section>\n  );\n};\n\n\nexport default AuthCard;\n\n","\nimport { useEffect } from 'react';\nimport { useHistory } from 'react-router-dom';\n\nimport TheotokosIcon from '../../components/UI/TheotokosIcon'\nimport AuthCard from '../../components/UI/AuthCard'\nimport '../../styles/auth.css';\nimport strings from '../../constants/strings';\n\nexport default function Auth() {\n  const history = useHistory();\n\n  const userIsLoggedIn = localStorage.getItem(strings.userData);\n\n  useEffect(() => {\n    if (!!userIsLoggedIn) history.replace('/')\n  }, [userIsLoggedIn, history]);\n\n  return (\n    <div className='auth' >\n      <TheotokosIcon />\n      <AuthCard />\n    </div>\n  )\n}\n","import { useEffect, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { RootStateOrAny, useDispatch, useSelector } from 'react-redux';\nimport { MdTimer, MdTimerOff } from 'react-icons/md';\n\nimport \"../styles/topbar.css\";\nimport nav from '../constants/nav';\nimport { timerState } from '../store/actions/game';\n\nexport default function Topbar(props: any) {\n  const dispatch = useDispatch();\n  const history = useHistory();\n\n  const [timer, setTimer] = useState(false);\n\n  const gameTitle = useSelector((state: RootStateOrAny) => state.game.gameTypeTitle);\n  const gameOn = useSelector((state: RootStateOrAny) => state.game.gameOn);\n\n  useEffect(() => {\n    dispatch(timerState(timer))\n  }, [dispatch, timer])\n\n  const toggleTimerIcon = () => {\n    setTimer(!timer);\n  };\n  const menuHandler = () => {\n    props.setMenuOpen(true);\n  };\n\n  return (\n    <div className={`topbar ${(props.menuOpen || gameOn) && \"active\"} `}>\n      <div className=\"hamburger-container\">\n        <div className='hamburger-icon' onClick={menuHandler}>\n          <span></span>\n          <span></span>\n          <span></span>\n        </div>\n      </div>\n      <div\n        className=\"title-container\"\n        onClick={() => history.push(nav.home)}\n      >\n        <h1\n          className={`title ${!!gameTitle ? 'title--game' : ''}`}>\n          {!!gameTitle ? gameTitle : 'ΕΝ ΤΟΥΤΩ ΝΙΚΑ'}\n        </h1>\n      </div>\n      {timer ?\n        <MdTimer className=\"timer-icon\" size='34' onClick={toggleTimerIcon} /> :\n        <MdTimerOff onClick={toggleTimerIcon} className=\"timer-icon\" size='34' />\n      }\n    </div>\n  );\n}\n","import { Link } from 'react-router-dom';\nimport nav from '../../constants/nav';\nimport '../../styles/menu/donate.css';\n\nexport default function Donate() {\n  return (\n    <div >\n      <Link to={nav.donate} >Donate</Link>\n\n    </div>\n  )\n}\n","import '../../styles/game/multi-categories.css'\nexport default function MultiCategories() {\n  return (\n    <div className='multi-categories' >\n      MultiCategories\n    </div>\n  )\n}\n","import '../../styles/grid-items/grid-tile.css';\n\ninterface Image {\n  borderColor: string,\n  borderWidth: number,\n  image: string,\n  title: string\n  onClick: any\n}\n\nconst GridTile = ({\n  borderColor,\n  borderWidth,\n  image,\n  onClick,\n  title, }: Image): any => {\n  return (\n    <li>\n      <div onClick={onClick} className='categories-item' >\n        <div className='categories-item__image-container'  >\n          <img\n            src={image}\n            alt=\"images for categories\"\n            style={{ borderColor, borderWidth }}\n          />\n        </div>\n        <span className='categories-item__title'>{title}</span>\n      </div>\n    </li>\n  )\n}\n\nexport default GridTile;","import colors from \"../../constants/colors\";\n\nexport interface GameStatusMulti {\n  questionsMultiOne: boolean,\n  questionsMultiTwo: boolean,\n  questionsMultiThree: boolean,\n  questionsMultiFour: boolean,\n  questionsMultiOneNoTimer: boolean,\n  questionsMultiTwoNoTimer: boolean,\n  questionsMultiThreeNoTimer: boolean,\n  questionsMultiFourNoTimer: boolean,\n}\n\nconst jesus = \"../../../assets/jesus-categories.jpg\";\n// const theotokos = \"../../../assets/panagia-glykofilousa-for-categories.jpg\";\n// const john = \"../../../assets/john-for-categories.jpg\";\n\nconst chrisostomos = \"../../../assets/chrisostomos.jpg\";\nconst david = \"../../../assets/david.jpg\";\nconst agioipantes = \"../../../assets/agioipantes.jpg\";\nconst eksomologisi = \"../../../assets/eksomologisi.jpg\";\n\n\nconst imageHandler = (gamesStatus: any, id: string, timer: boolean) => {\n  const color: string = colors.cyan;\n  let image: string = jesus;\n  let borderColor: string = \"white\";\n  let borderWidth: number = 2;\n  // let shadowColor: string = colors.moccasin_light;\n\n  const adjustBorderColor = (gameOn: boolean) => {\n    if (gameOn) {\n      borderColor = color;\n      borderWidth = 4;\n    }\n  };\n  switch (id) {\n    case \"c1\":\n      image = chrisostomos;\n      adjustBorderColor(\n        timer\n          ? gamesStatus.questionsMultiOne\n          : gamesStatus.questionsMultiOneNoTimer\n      );\n      break;\n    case \"c2\":\n      image = david;\n      adjustBorderColor(\n        timer\n          ? gamesStatus.questionsMultiTwo\n          : gamesStatus.questionsMultiTwoNoTimer\n      );\n      break;\n    case \"c3\":\n      image = agioipantes;\n      adjustBorderColor(\n        timer\n          ? gamesStatus.questionsMultiThree\n          : gamesStatus.questionsMultiThreeNoTimer\n      );\n      break;\n    case \"c4\":\n      image = eksomologisi;\n      adjustBorderColor(\n        timer\n          ? gamesStatus.questionsMultiFour\n          : gamesStatus.questionsMultiFourNoTimer\n      );\n      break;\n    default:\n      break;\n  }\n  return { borderColor, borderWidth, image };\n};\n\nexport default imageHandler;","import colors from \"../../constants/colors\";\nimport strings from \"../../constants/strings\";\nimport { store } from \"../../store/configureStore\";\n\nconst jesus = \"assets/jesus-categories.jpg\";\n\nconst imageHandler = () => {\n\n  const gameType = store.getState().game.id;\n  const timer = store.getState().game.timer;\n\n  let gameOn;\n\n  const color: string = colors.cyan;\n  let image: string = jesus;\n  let borderColor: string = \"white\";\n  let borderWidth: number = 2;\n\n\n  if (gameType === \"Multi\") {\n    if (timer) {\n      gameOn = localStorage.getItem(strings.mixGameIsOnMulti);\n    } else {\n      gameOn = localStorage.getItem(strings.mixGameIsOnMultiNoTimer);\n    }\n  } else if (gameType === \"TrueFalse\") {\n    if (timer) {\n      gameOn = localStorage.getItem(strings.mixGameIsOnTrueFalse);\n    } else {\n      gameOn = localStorage.getItem(strings.mixGameIsOnTrueFalseNoTimer);\n    }\n  }\n\n  if (gameOn) {\n    borderColor = color;\n    borderWidth = 4;\n  }\n\n  return { borderColor, borderWidth, image };\n};\n\nexport default imageHandler;","import nav from \"../../constants/nav\";\n\nimport GridTile from \"./GridTile\";\nimport imageHandler from \"./imageHandler\";\n// import imageHandlerCreate from \"./imageHandlerCreate\";\n// import imageHandlerTrueFalse, { GameStatusTrueFalse } from \"./imageHandlerTrueFalse\";\n// import { GameStatusMulti } from './imageHandler'\nimport imageHandlerMix from \"./imageHandlerMix\";\n\n// gamesStatus: GameStatusMulti | GameStatusTrueFalse\ninterface CategoryGridTileProps {\n  gamesStatus: any,\n  id: string,\n  navigationName: string,\n  onClick: any,\n  timer: boolean,\n  title: string,\n}\n\n// interface Image {\n//   borderColor: any,\n//   borderWidth: number,\n//   image: string,\n//   shadowColor: string\n// }\n// NOTE:\n// We have a separate CategoryGridTileNoTimer, because in case of error,\n// CategoryGridTile, would get a gameOn in NoTimerMultiGameScreen.\nconst CategoryGridTileNoTimer = ({\n  gamesStatus,\n  id,\n  navigationName,\n  onClick,\n  timer,\n  title,\n}: CategoryGridTileProps): any => {\n  let borderC: string = '', borderW: number = 0, img: string = '';\n\n  if (id === 'mixed') {\n    const { borderColor, borderWidth, image } = imageHandlerMix();\n    borderC = borderColor; borderW = borderWidth; img = image;\n  } else if (navigationName === nav.multiGameNoTimer) {\n    const { borderColor, borderWidth, image } = imageHandler(gamesStatus, id, timer);\n    borderC = borderColor; borderW = borderWidth; img = image;\n  }\n\n  // if (navigationName === nav.trueFalseGameNoTimer) {\n  //   const { borderColor, borderWidth, image } = imageHandlerTrueFalse(gamesStatus, id, timer);\n  //   borderC = borderColor; borderW = borderWidth; img = image;\n\n  // }\n  // if (navigationName === nav.createHome) {\n  //   const { borderColor, borderWidth, image } = imageHandlerCreate(id);\n  //   borderC = borderColor; borderW = borderWidth; img = image;\n  // }\n\n  return (\n    <GridTile\n      borderColor={borderC}\n      borderWidth={borderW}\n      image={img}\n      onClick={onClick}\n      title={title}\n    />\n  );\n};\n\nexport default CategoryGridTileNoTimer;","import IconCard from \"../models/icon-card\";\n\nexport const CATEGORIES = [\n  new IconCard(\"mixed\", \"Απάνθισμα\"),\n  new IconCard(\"c1\", \"Καινή Διαθήκη\"),\n  new IconCard(\"c2\", \"Παλαιά Διαθήκη\"),\n  new IconCard(\"c3\", \"Συναξάρι\"),\n  new IconCard(\"c4\", \"Αγιοπνευματική ζωή\"),\n  // new IconCard('5', 'Αγιοπνευματική ζωή'),\n  // new IconCard('6', 'Αγιολογία'),\n  // new IconCard('7', 'Λειτουργική'),\n  // new IconCard('8', 'Εικονολογία'),\n  // new IconCard('9', 'Εκκλησιαστική Ιστορία'),\n  // new IconCard('10', 'Εκκλησιαστική μουσική'),\n];\n\n// export const CATEGORIES = [\n// \tnew IconCard('1', 'Καινή Διαθήκη'),\n// \tnew IconCard('2', 'Παλαιά Διαθήκη'),\n// \tnew IconCard('3', 'Πατρολογία'),\n// \tnew IconCard('4', 'Δογματική'),\n// \tnew IconCard('5', 'Αγιοπνευματική ζωή'),\n// \tnew IconCard('6', 'Αγιολογία'),\n// \tnew IconCard('7', 'Λειτουργική'),\n// \tnew IconCard('8', 'Εικονολογία'),\n// \tnew IconCard('9', 'Εκκλησιαστική Ιστορία'),\n// \tnew IconCard('10', 'Εκκλησιαστική μουσική'),\n// ];\n","import cache from \"./cache\";\nimport strings from \"../constants/strings\";\n\nconst getGameStatusMulti = (setGamesStatus: Function) => {\n\n  let questionsMultiOne: Array<object> = [];\n  let questionsMultiTwo: Array<object> = [];\n  let questionsMultiThree: Array<object> = [];\n  let questionsMultiFour: Array<object> = [];\n  let questionsMultiOneNoTimer: Array<object> = [];\n  let questionsMultiTwoNoTimer: Array<object> = [];\n  let questionsMultiThreeNoTimer: Array<object> = [];\n  let questionsMultiFourNoTimer: Array<object> = [];\n\n  const checkCategories = async () => {\n    questionsMultiOne = await cache.get(strings.questionsMultiOne);\n    questionsMultiTwo = await cache.get(strings.questionsMultiTwo);\n    questionsMultiThree = await cache.get(strings.questionsMultiThree);\n    questionsMultiFour = await cache.get(strings.questionsMultiFour);\n    questionsMultiOneNoTimer = await cache.get(\n      strings.questionsMultiOneNoTimer\n    );\n    questionsMultiTwoNoTimer = await cache.get(\n      strings.questionsMultiTwoNoTimer\n    );\n    questionsMultiThreeNoTimer = await cache.get(\n      strings.questionsMultiThreeNoTimer\n    );\n    questionsMultiFourNoTimer = await cache.get(\n      strings.questionsMultiFourNoTimer\n    );\n  };\n\n  checkCategories().then(() => {\n    if (\n      !!questionsMultiOne ||\n      !!questionsMultiTwo ||\n      !!questionsMultiThree ||\n      !!questionsMultiFour ||\n      !!questionsMultiOneNoTimer ||\n      !!questionsMultiTwoNoTimer ||\n      !!questionsMultiThreeNoTimer ||\n      !!questionsMultiFourNoTimer\n    ) {\n      setGamesStatus({\n        questionsMultiOne: !!questionsMultiOne,\n        questionsMultiTwo: !!questionsMultiTwo,\n        questionsMultiThree: !!questionsMultiThree,\n        questionsMultiFour: !!questionsMultiFour,\n        questionsMultiOneNoTimer: !!questionsMultiOneNoTimer,\n        questionsMultiTwoNoTimer: !!questionsMultiTwoNoTimer,\n        questionsMultiThreeNoTimer: !!questionsMultiThreeNoTimer,\n        questionsMultiFourNoTimer: !!questionsMultiFourNoTimer,\n      });\n    }\n  });\n};\n\nexport default getGameStatusMulti;","import { useEffect, useState } from 'react';\nimport { useHistory } from 'react-router-dom';\nimport { RootStateOrAny, useSelector, useDispatch } from 'react-redux'\nimport CategoryGridTileNoTimer from '../../components/grid-items/CategoryGridTileNoTimer';\n\n// import GridItemHome from '../../components/grid-items/GridItemHome';\n// import renderGridItemHandler from '../../components/grid-items/renderGridItemHandler';\nimport nav from '../../constants/nav';\nimport { CATEGORIES } from '../../data/categories';\nimport { gameTypeTitle } from '../../store/actions/game';\nimport '../../styles/game/multi-categories-no-timer.css'\nimport getGameStatusMulti from '../../utils/getGameStatusMulti';\nimport cache from '../../utils/cache';\nimport strings from '../../constants/strings';\n// import { GameStatusMulti } from '../../components/grid-items/imageHandler';\n\n// interface GameStatusMulti {\n//   questionsMultiOne: boolean,\n//   questionsMultiTwo: boolean,\n//   questionsMultiThree: boolean,\n//   questionsMultiFour: boolean,\n//   questionsMultiOneNoTimer: boolean,\n//   questionsMultiTwoNoTimer: boolean,\n//   questionsMultiThreeNoTimer: boolean,\n//   questionsMultiFourNoTimer: boolean,\n// }\n\nconst MultiCategoriesNoTimer = (props: any): any => {\n  const dispatch = useDispatch();\n  const history = useHistory();\n\n  const [mixGameIsOn, setMixGameIsOn] = useState(false);\n  const [mixGameIsOnNoTimer, setMixGameIsOnNoTimer] = useState(false);\n  const [mixGameIsOnTF, setMixGameIsOnTF] = useState(false);\n  const [mixGameIsOnTFNoTimer, setMixGameIsOnTFNoTimer] = useState(false);\n  const [gamesStatus, setGamesStatus] = useState<any>({});\n  // const [gamesStatus, setGamesStatus] = useState<GameStatusMulti>({\n  //   questionsMultiOne: false,\n  //   questionsMultiTwo: false,\n  //   questionsMultiThree: false,\n  //   questionsMultiFour: false,\n  //   questionsMultiOneNoTimer: false,\n  //   questionsMultiTwoNoTimer: false,\n  //   questionsMultiThreeNoTimer: false,\n  //   questionsMultiFourNoTimer: false,\n  // });\n  const timer = useSelector((state: RootStateOrAny) => state.game.timer);\n  const gameType = useSelector((state: RootStateOrAny) => state.game.id);\n\n  const checking = async () => {\n    if (gameType === \"Multi\") {\n      if (timer) {\n        const isOn = await cache.get(strings.mixGameIsOnMulti);\n        setMixGameIsOn(isOn)\n      } else {\n        const isOn = await cache.get(strings.mixGameIsOnMultiNoTimer);\n        setMixGameIsOnNoTimer(isOn)\n      }\n    } else if (gameType === \"TrueFalse\") {\n      if (timer) {\n        const isOn = await cache.get(strings.mixGameIsOnTrueFalse);\n        setMixGameIsOnTF(isOn)\n      } else {\n        const isOn = await cache.get(strings.mixGameIsOnTrueFalseNoTimer);\n        setMixGameIsOnTFNoTimer(isOn)\n      }\n    }\n  }\n\n  useEffect(() => {\n    checking();\n  });\n\n  useEffect(() => {\n    dispatch(gameTypeTitle('Πολλαπλών Επιλογών'))\n  }, [dispatch])\n\n  useEffect(() => {\n    getGameStatusMulti(setGamesStatus);\n  }, []);\n\n\n  return (\n    <div className='multi-categories-no-timer'>\n      <ul>\n        {CATEGORIES.map((game: { id: string, title: string }) =>\n          <CategoryGridTileNoTimer\n            key={game.id}\n            gamesStatus={gamesStatus}\n            id={game.id}\n            navigationName={nav.multiGameNoTimer}\n            timer={timer}\n            title={game.title}\n            onClick={() => {\n              const getNavigationName = () => {\n                if (mixGameIsOn ||\n                  mixGameIsOnNoTimer ||\n                  mixGameIsOnTF ||\n                  mixGameIsOnTFNoTimer) return {\n                    pathname: nav.mixGameIsOn,\n                    state: {\n                      mixGameIsOn,\n                      mixGameIsOnNoTimer,\n                      mixGameIsOnTF,\n                      mixGameIsOnTFNoTimer\n                    }\n                  }\n                if (game.id === \"mixed\") return nav.mixChooseCategories\n                else return nav.multiGameNoTimer;\n              }\n              history.push(getNavigationName())\n            }\n            }\n          />\n        )}\n      </ul>\n    </div>\n  )\n}\n\nexport default MultiCategoriesNoTimer;","export interface Question {\n\taccepted: boolean;\n\tindex?: number;\n\tid: string;\n\tcategoryIds: string;\n\townerId: string;\n\ttitle: string;\n\tanswer: string;\n\tsource: string;\n\tchoice_Alpha?: string;\n\tchoice_Beta?: string;\n\tchoice_Gamma?: string;\n\tchoice_Delta?: string;\n\tright_choice: number;\n\thint: string;\n}\n\nfunction question(this: Question, info: Question) {\n\tthis.accepted = info.accepted;\n\tthis.index = info.index;\n\tthis.id = info.id;\n\tthis.categoryIds = info.categoryIds;\n\tthis.ownerId = info.ownerId;\n\tthis.title = info.title;\n\tthis.answer = info.answer;\n\tthis.source = info.source;\n\tthis.choice_Alpha = info.choice_Alpha;\n\tthis.choice_Beta = info.choice_Beta;\n\tthis.choice_Gamma = info.choice_Gamma;\n\tthis.choice_Delta = info.choice_Delta;\n\tthis.right_choice = info.right_choice;\n\tthis.index = info.index;\n}\n\nexport default question;\n","// export default shuffle = (array) => {\n//     var currentIndex = array.length,\n//         temporaryValue,\n//         randomIndex;\n\n//     // While there remain elements to shuffle...\n//     while (0 !== currentIndex) {\n//         // Pick a remaining element...\n//         randomIndex = Math.floor(Math.random() * currentIndex);\n//         currentIndex -= 1;\n\n//         // And swap it with the current element.\n//         temporaryValue = array[currentIndex];\n//         array[currentIndex] = array[randomIndex];\n//         array[randomIndex] = temporaryValue;\n//     }\n\n//     return array;\n// };\n\nconst shuffle = (array: Array<any>) => {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [array[i], array[j]] = [array[j], array[i]];\n  }\n  return array;\n};\n\nexport default shuffle;","import * as mixedQuestions from \"./mixedQuestions\";\nimport * as mixedQuestionsTrueFalse from \"./mixedQuestionsTrueFalse\";\nimport * as questionsMultiOne from \"./questionsMultiOne\";\nimport * as questionsMultiTwo from \"./questionsMultiTwo\";\nimport * as questionsMultiThree from \"./questionsMultiThree\";\nimport * as questionsMultiFour from \"./questionsMultiFour\";\nimport * as questionsTrueFalseOne from \"./questionsTrueFalseOne\";\nimport * as questionsTrueFalseTwo from \"./questionsTrueFalseTwo\";\nimport * as questionsTrueFalseThree from \"./questionsTrueFalseThree\";\nimport * as questionsTrueFalseFour from \"./questionsTrueFalseFour\";\n\nconst fetchQuestionsMultiMixed = mixedQuestions.fetchQuestionsMultiMixed;\nconst fetchQuestionsTrueFalseMixed =\n  mixedQuestionsTrueFalse.fetchQuestionsTrueFalseMixed;\n\nexport { fetchQuestionsMultiMixed };\nexport { fetchQuestionsTrueFalseMixed };\n\nconst createQuestionForMultiOne = questionsMultiOne.createQuestionForMultiOne;\nconst updateQuestionForMultiOne = questionsMultiOne.updateQuestionForMultiOne;\nconst deleteQuestionForMultiOne = questionsMultiOne.deleteQuestionForMultiOne;\nconst fetchQuestionsForMultiOne = questionsMultiOne.fetchQuestionsForMultiOne;\nconst fetchQuestionsForMultiOneNoTimer =\n  questionsMultiOne.fetchQuestionsForMultiOneNoTimer;\nconst fetchQuestionsForMixedOne = questionsMultiOne.fetchQuestionsForMixedOne;\n\nexport { createQuestionForMultiOne };\nexport { updateQuestionForMultiOne };\nexport { deleteQuestionForMultiOne };\nexport { fetchQuestionsForMultiOne };\nexport { fetchQuestionsForMultiOneNoTimer };\nexport { fetchQuestionsForMixedOne };\n\nconst createQuestionForMultiTwo = questionsMultiTwo.createQuestionForMultiTwo;\nconst updateQuestionForMultiTwo = questionsMultiTwo.updateQuestionForMultiTwo;\nconst deleteQuestionForMultiTwo = questionsMultiTwo.deleteQuestionForMultiTwo;\nconst fetchQuestionsForMultiTwo = questionsMultiTwo.fetchQuestionsForMultiTwo;\nconst fetchQuestionsForMultiTwoNoTimer =\n  questionsMultiTwo.fetchQuestionsForMultiTwoNoTimer;\nconst fetchQuestionsForMixedTwo = questionsMultiTwo.fetchQuestionsForMixedTwo;\n\nexport { createQuestionForMultiTwo };\nexport { updateQuestionForMultiTwo };\nexport { deleteQuestionForMultiTwo };\nexport { fetchQuestionsForMultiTwo };\nexport { fetchQuestionsForMultiTwoNoTimer };\nexport { fetchQuestionsForMixedTwo };\n\nconst createQuestionForMultiThree =\n  questionsMultiThree.createQuestionForMultiThree;\nconst updateQuestionForMultiThree =\n  questionsMultiThree.updateQuestionForMultiThree;\nconst deleteQuestionForMultiThree =\n  questionsMultiThree.deleteQuestionForMultiThree;\nconst fetchQuestionsForMultiThree =\n  questionsMultiThree.fetchQuestionsForMultiThree;\nconst fetchQuestionsForMultiThreeNoTimer =\n  questionsMultiThree.fetchQuestionsForMultiThreeNoTimer;\nconst fetchQuestionsForMixedThree =\n  questionsMultiThree.fetchQuestionsForMixedThree;\n\nexport { createQuestionForMultiThree };\nexport { updateQuestionForMultiThree };\nexport { deleteQuestionForMultiThree };\nexport { fetchQuestionsForMultiThree };\nexport { fetchQuestionsForMultiThreeNoTimer };\nexport { fetchQuestionsForMixedThree };\n\nconst createQuestionForMultiFour =\n  questionsMultiFour.createQuestionForMultiFour;\nconst updateQuestionForMultiFour =\n  questionsMultiFour.updateQuestionForMultiFour;\nconst deleteQuestionForMultiFour =\n  questionsMultiFour.deleteQuestionForMultiFour;\nconst fetchQuestionsForMultiFour =\n  questionsMultiFour.fetchQuestionsForMultiFour;\nconst fetchQuestionsForMultiFourNoTimer =\n  questionsMultiFour.fetchQuestionsForMultiFourNoTimer;\nconst fetchQuestionsForMixedFour =\n  questionsMultiFour.fetchQuestionsForMixedFour;\n\nexport { createQuestionForMultiFour };\nexport { updateQuestionForMultiFour };\nexport { deleteQuestionForMultiFour };\nexport { fetchQuestionsForMultiFour };\nexport { fetchQuestionsForMultiFourNoTimer };\nexport { fetchQuestionsForMixedFour };\n\nconst createQuestionForTrueFalseOne =\n  questionsTrueFalseOne.createQuestionForTrueFalseOne;\nconst deleteQuestionForTrueFalseOne =\n  questionsTrueFalseOne.deleteQuestionForTrueFalseOne;\nconst fetchQuestionsForTrueFalseOne =\n  questionsTrueFalseOne.fetchQuestionsForTrueFalseOne;\nconst fetchQuestionsForTrueFalseOneMixed =\n  questionsTrueFalseOne.fetchQuestionsForTrueFalseOneMixed;\nconst updateQuestionForTrueFalseOne =\n  questionsTrueFalseOne.updateQuestionForTrueFalseOne;\n\nexport { createQuestionForTrueFalseOne };\nexport { deleteQuestionForTrueFalseOne };\nexport { fetchQuestionsForTrueFalseOne };\nexport { fetchQuestionsForTrueFalseOneMixed };\nexport { updateQuestionForTrueFalseOne };\n\nconst createQuestionForTrueFalseTwo =\n  questionsTrueFalseTwo.createQuestionForTrueFalseTwo;\nconst deleteQuestionForTrueFalseTwo =\n  questionsTrueFalseTwo.deleteQuestionForTrueFalseTwo;\nconst fetchQuestionsForTrueFalseTwo =\n  questionsTrueFalseTwo.fetchQuestionsForTrueFalseTwo;\nconst fetchQuestionsForTrueFalseTwoMixed =\n  questionsTrueFalseTwo.fetchQuestionsForTrueFalseTwoMixed;\nconst updateQuestionForTrueFalseTwo =\n  questionsTrueFalseTwo.updateQuestionForTrueFalseTwo;\n\nexport { createQuestionForTrueFalseTwo };\nexport { deleteQuestionForTrueFalseTwo };\nexport { fetchQuestionsForTrueFalseTwo };\nexport { fetchQuestionsForTrueFalseTwoMixed };\nexport { updateQuestionForTrueFalseTwo };\n\nconst createQuestionForTrueFalseThree =\n  questionsTrueFalseThree.createQuestionForTrueFalseThree;\nconst deleteQuestionForTrueFalseThree =\n  questionsTrueFalseThree.deleteQuestionForTrueFalseThree;\nconst fetchQuestionsForTrueFalseThree =\n  questionsTrueFalseThree.fetchQuestionsForTrueFalseThree;\nconst fetchQuestionsForTrueFalseThreeMixed =\n  questionsTrueFalseThree.fetchQuestionsForTrueFalseThreeMixed;\nconst updateQuestionForTrueFalseThree =\n  questionsTrueFalseThree.updateQuestionForTrueFalseThree;\n\nexport { createQuestionForTrueFalseThree };\nexport { deleteQuestionForTrueFalseThree };\nexport { fetchQuestionsForTrueFalseThree };\nexport { fetchQuestionsForTrueFalseThreeMixed };\nexport { updateQuestionForTrueFalseThree };\n\nconst createQuestionForTrueFalseFour =\n  questionsTrueFalseFour.createQuestionForTrueFalseFour;\nconst deleteQuestionForTrueFalseFour =\n  questionsTrueFalseFour.deleteQuestionForTrueFalseFour;\nconst fetchQuestionsForTrueFalseFour =\n  questionsTrueFalseFour.fetchQuestionsForTrueFalseFour;\nconst fetchQuestionsForTrueFalseFourMixed =\n  questionsTrueFalseFour.fetchQuestionsForTrueFalseFourMixed;\nconst updateQuestionForTrueFalseFour =\n  questionsTrueFalseFour.updateQuestionForTrueFalseFour;\n\nexport { createQuestionForTrueFalseFour };\nexport { deleteQuestionForTrueFalseFour };\nexport { fetchQuestionsForTrueFalseFour };\nexport { fetchQuestionsForTrueFalseFourMixed };\nexport { updateQuestionForTrueFalseFour };\n\n// We need to do the above work around untill React-Native -v 0.61\n// https://github.com/facebook/react-native/issues/22592\n\n// export * from './mixedQuestions'\n// export * from './alfaQuestions'\n// export * from './betaQuestions'\n// export * from './gammaQuestions'\n// export * from './deltaQuestions'\n// export * from './questionsMultiOne'\n// export * from './twoQuestions'\n// export * from './threeQuestions'\n// export * from './fourQuestions'\n// export * from './fiveQuestions'\n// export * from './sixQuestions'\n// export * from './sevenQuestions'\n// export * from './eightQuestions'\n// export * from './nineQuestions'\n// export * from './tenQuestions'\n","import cache from \"../../../utils/cache\";\nimport question from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport strings from \"../../../constants/strings\";\n\nexport const fetchQuestionsMultiMixed = () => {\n  return async () => {\n    try {\n      const mixedQuestions = [];\n      const localDataBaseMultiMixedOne = await cache.get(\n        strings.localDataBaseMultiMixedOne\n      );\n      const check_one = await cache.get(\"check_one\");\n\n      const localDataBaseMultiMixedTwo = await cache.get(\n        strings.localDataBaseMultiMixedTwo\n      );\n      const check_two = await cache.get(\"check_two\");\n\n      const localDataBaseMultiMixedThree = await cache.get(\n        strings.localDataBaseMultiMixedThree\n      );\n      const check_three = await cache.get(\"check_three\");\n\n      const localDataBaseMultiMixedFour = await cache.get(\n        strings.localDataBaseMultiMixedFour\n      );\n      const check_four = await cache.get(\"check_four\");\n\n      // console.log('in mixedQuestions for alfaOne', alfaOneQuestionsMixedAreON, check_one);\n\n      ///////////////////////\n      if (!!localDataBaseMultiMixedOne && check_one) {\n        const questions = await cache.get(\n          strings.localDataBaseMultiMixedOne\n        );\n\n        for (const key in questions) {\n          mixedQuestions.push(\n            new (question as any)({\n              accepted: questions[key].accepted,\n              index: questions[key].index, // for keeping the choice in cartScreen\n              id: key,\n              categoryIds: questions[key].categoryIds,\n              ownerId: questions[key].ownerId,\n              title: questions[key].title,\n              answer: questions[key].answer,\n              source: questions[key].source,\n              choice_Alpha: questions[key].choice_Alpha,\n              choice_Beta: questions[key].choice_Beta,\n              choice_Gamma: questions[key].choice_Gamma,\n              choice_Delta: questions[key].choice_Delta,\n              right_choice: questions[key].right_choice,\n              hint: questions[key].hint,\n            })\n          );\n        }\n      }\n      if (!!localDataBaseMultiMixedTwo && check_two) {\n        const questions = await cache.get(\n          strings.localDataBaseMultiMixedTwo\n        );\n\n        for (const key in questions) {\n          mixedQuestions.push(\n            new (question as any)({\n              accepted: questions[key].accepted,\n              index: questions[key].index, // for keeping the choice in cartScreen\n              id: key,\n              categoryIds: questions[key].categoryIds,\n              ownerId: questions[key].ownerId,\n              title: questions[key].title,\n              answer: questions[key].answer,\n              source: questions[key].source,\n              choice_Alpha: questions[key].choice_Alpha,\n              choice_Beta: questions[key].choice_Beta,\n              choice_Gamma: questions[key].choice_Gamma,\n              choice_Delta: questions[key].choice_Delta,\n              right_choice: questions[key].right_choice,\n              hint: questions[key].hint,\n            })\n          );\n        }\n      }\n\n      if (localDataBaseMultiMixedThree && check_three) {\n        const questions = await cache.get(\n          strings.localDataBaseMultiMixedThree\n        );\n\n        for (const key in questions) {\n          mixedQuestions.push(\n            new (question as any)({\n              accepted: questions[key].accepted,\n              index: questions[key].index, // for keeping the choice in cartScreen\n              id: key,\n              categoryIds: questions[key].categoryIds,\n              ownerId: questions[key].ownerId,\n              title: questions[key].title,\n              answer: questions[key].answer,\n              source: questions[key].source,\n              choice_Alpha: questions[key].choice_Alpha,\n              choice_Beta: questions[key].choice_Beta,\n              choice_Gamma: questions[key].choice_Gamma,\n              choice_Delta: questions[key].choice_Delta,\n              right_choice: questions[key].right_choice,\n              hint: questions[key].hint,\n            })\n          );\n        }\n      }\n      if (!!localDataBaseMultiMixedFour && check_four) {\n        const questions = await cache.get(\n          strings.localDataBaseMultiMixedFour\n        );\n\n        for (const key in questions) {\n          mixedQuestions.push(\n            new (question as any)({\n              accepted: questions[key].accepted,\n              index: questions[key].index, // for keeping the choice in cartScreen\n              id: key,\n              categoryIds: questions[key].categoryIds,\n              ownerId: questions[key].ownerId,\n              title: questions[key].title,\n              answer: questions[key].answer,\n              source: questions[key].source,\n              choice_Alpha: questions[key].choice_Alpha,\n              choice_Beta: questions[key].choice_Beta,\n              choice_Gamma: questions[key].choice_Gamma,\n              choice_Delta: questions[key].choice_Delta,\n              right_choice: questions[key].right_choice,\n              hint: questions[key].hint,\n            })\n          );\n        }\n      }\n\n      const shuffledQuestions = shuffle(mixedQuestions);\n      // const array = shuffledQuestions.splice(0, 1);\n      await cache.set(strings.questionsMultiMixed, shuffledQuestions);\n    } catch (err) {\n      // send to custom analytics server\n      alert(\n        \"Η λήψει των ερωτήσεων για το Απάνθισμα απέτυχε!\"\n      );\n\n      throw err;\n    }\n  };\n};\n","import cache from \"../../../utils/cache\";\nimport question, { Question } from \"../../../models/question\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForMultiOne = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiOne.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForMultiOne.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      alert(\n        \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\");\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForMultiOne = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiOne/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiOne = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiOne = await cache.get(\n        strings.localDataBaseMultiOne\n      );\n\n      if (!localDataBaseMultiOne) {\n        await cache.set(strings.localDataBaseMultiOne, acceptedQuestions);\n      }\n\n      // download the questions the user created\n      await cache.set(strings.createdQuestionsMultiOne, loadedQuestions);\n\n      // const shuffledQuestions = shuffle(acceptedQuestions);\n      await cache.set(strings.questionsMultiOne, acceptedQuestions);\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\n// Use a separate function for NoTimer, because if user tries to play with timer\n// and an error occurs in the download, the gamesStatus will get the timer variable as false,\n// so it will appear like he started a game with NoTimer.\nexport const fetchQuestionsForMultiOneNoTimer = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiOne = await cache.get(\n        strings.localDataBaseMultiOne\n      );\n\n      if (!localDataBaseMultiOne) {\n        await cache.set(strings.localDataBaseMultiOne, acceptedQuestions);\n      }\n\n      // download the questions the user created\n      await cache.set(strings.createdQuestionsMultiOne, loadedQuestions);\n\n      // const shuffledQuestions = shuffle(acceptedQuestions);\n      await cache.set(strings.questionsMultiOneNoTimer, acceptedQuestions);\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMixedOne = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const alfaOneDataBaseMixed = await cache.get(\n        strings.localDataBaseMultiMixedOne\n      );\n      if (!alfaOneDataBaseMixed) {\n        await cache.set(\n          strings.localDataBaseMultiMixedOne,\n          acceptedQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForMultiOne = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForMultiOne/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForMultiOne.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","\nimport question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport strings from \"../../../constants/strings\";\nimport cache from \"../../../utils/cache\";\n\nexport const createQuestionForMultiTwo = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForMultiTwo.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForMultiTwo = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiTwo = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiTwo = await localStorage.getItem(\n        strings.localDataBaseMultiTwo\n      );\n\n      if (!localDataBaseMultiTwo) {\n        await localStorage.setItem(\n          strings.localDataBaseMultiTwo,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n\n      // set here if user is ther creator of the question\n      await localStorage.setItem(\n        strings.createdQuestionsMultiTwo,\n        JSON.stringify(loadedQuestions)\n      );\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      await localStorage.setItem(\n        strings.questionsMultiTwo,\n        JSON.stringify(shuffledQuestions)\n      );\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiTwoNoTimer = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiTwo = await localStorage.getItem(\n        strings.localDataBaseMultiTwo\n      );\n\n      if (!localDataBaseMultiTwo) {\n        await localStorage.setItem(\n          strings.localDataBaseMultiTwo,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n\n      // set here if user is ther creator of the question\n      await localStorage.setItem(\n        strings.createdQuestionsMultiTwo,\n        JSON.stringify(loadedQuestions)\n      );\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      await localStorage.setItem(\n        strings.questionsMultiTwoNoTimer,\n        JSON.stringify(shuffledQuestions)\n      );\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMixedTwo = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI = \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const alfaTwoDataBaseMixed = await localStorage.getItem(\n        strings.localDataBaseMultiMixedTwo\n      );\n      if (!alfaTwoDataBaseMixed) {\n        await localStorage.setItem(\n          strings.localDataBaseMultiMixedTwo,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForMultiTwo = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForMultiTwo.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import cache from \"../../../utils/cache\";\nimport question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForMultiThree = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiThree.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForMultiThree.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForMultiThree = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n\n      const { token, userId } = await cache.get(strings.userData);\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiThree/${userId\n          }.json ? auth = ${token} `;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199/${userId\n          }.json ? auth = ${token} `;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiThree = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiThree = await cache.get(\n        strings.localDataBaseMultiThree\n      );\n\n      if (!localDataBaseMultiThree) {\n        await cache.set(strings.localDataBaseMultiThree, acceptedQuestions);\n      }\n\n      await cache.set(strings.createdQuestionsMultiThree, loadedQuestions);\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      await cache.set(strings.questionsMultiThree, shuffledQuestions);\n\n      // console.log('loadedQuestions', loadedQuestions);\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiThreeNoTimer = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiThree = await cache.get(\n        strings.localDataBaseMultiThree\n      );\n\n      if (!localDataBaseMultiThree) {\n        await cache.set(strings.localDataBaseMultiThree, acceptedQuestions);\n      }\n\n      await cache.set(strings.createdQuestionsMultiThree, loadedQuestions);\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      await cache.set(strings.questionsMultiThreeNoTimer, shuffledQuestions);\n\n      // console.log('loadedQuestions', loadedQuestions);\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMixedThree = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        // console.log('question', question.accepted);\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const alfaThreeDataBaseMixed = await cache.get(\n        strings.localDataBaseMultiMixedThree\n      );\n\n      if (!alfaThreeDataBaseMixed) {\n        await cache.set(\n          strings.localDataBaseMultiMixedThree,\n          acceptedQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForMultiThree = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForMultiThree/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForMultiThree.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","\nimport question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport strings from \"../../../constants/strings\";\nimport cache from \"../../../utils/cache\";\n\nexport const createQuestionForMultiFour = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray: Array<string> = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiFour.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForMultiFour.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        alert(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\");\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      alert(\n        \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\");\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForMultiFour = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  choice_Alpha: string,\n  choice_Beta: string,\n  choice_Gamma: string,\n  choice_Delta: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiFour/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          choice_Alpha,\n          choice_Beta,\n          choice_Gamma,\n          choice_Delta,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiFour = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiFour = await localStorage.getItem(\n        strings.localDataBaseMultiFour\n      );\n\n      if (!localDataBaseMultiFour) {\n        localStorage.setItem(\n          strings.localDataBaseMultiFour,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      localStorage.setItem(\n        strings.questionsMultiFour,\n        JSON.stringify(shuffledQuestions)\n      );\n\n      // ...\n      if (true) {\n        localStorage.setItem(\n          strings.createdQuestionsMultiFour,\n          JSON.stringify(loadedQuestions)\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForMultiFourNoTimer = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDataBaseMultiFour = localStorage.getItem(\n        strings.localDataBaseMultiFour\n      );\n\n      if (!localDataBaseMultiFour) {\n        localStorage.setItem(\n          strings.localDataBaseMultiFour,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      localStorage.setItem(\n        strings.questionsMultiFourNoTimer,\n        JSON.stringify(shuffledQuestions)\n      );\n      // ...\n      if (true) {\n        localStorage.setItem(\n          strings.createdQuestionsMultiFour,\n          JSON.stringify(loadedQuestions)\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\nexport const fetchQuestionsForMixedFour = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted, // for keeping the choice in cartScreen\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            choice_Alpha: questResData[key].choice_Alpha,\n            choice_Beta: questResData[key].choice_Beta,\n            choice_Gamma: questResData[key].choice_Gamma,\n            choice_Delta: questResData[key].choice_Delta,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        // console.log('question', question.accepted);\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const alfaFourDataBaseMixed = localStorage.getItem(\n        strings.localDataBaseMultiMixedFour\n      );\n\n      if (!alfaFourDataBaseMixed) {\n        localStorage.setItem(\n          strings.localDataBaseMultiMixedFour,\n          JSON.stringify(acceptedQuestions)\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForMultiFour = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForMultiFour/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForMultiFour.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport cache from \"../../../utils/cache\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForTrueFalseOne = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForTrueFalseOne.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.100-199.json?auth=${token}`;\n        }\n      }\n      // console.log('createQuestionForMultiOne', questionsArray.length);\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForTrueFalseOne = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForTrueFalseOne = (maxIndex: number,\n  trueFalse_useTimer: [boolean | 'created']) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        // console.log('question', question.accepted);\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      const oneTrueFalseDataBase = await cache.get(\n        strings.localDatabaseTrueFalseOne\n      );\n\n      if (!oneTrueFalseDataBase) {\n        await cache.set(\n          strings.localDatabaseTrueFalseOne,\n          shuffledQuestions\n        );\n      }\n\n      // if (trueFalse_useTimer && trueFalse_useTimer !== \"created\") {\n      await cache.set(strings.questionsTrueFalseOne, shuffledQuestions);\n      // }\n\n      if (!trueFalse_useTimer) {\n        await cache.set(\n          strings.questionsTrueFalseOneNoTimer,\n          shuffledQuestions\n        );\n      }\n\n      // if (trueFalse_useTimer == \"created\") {\n      // await cache.remove(strings.createdQuestionsTrueFalseOne);\n      await cache.set(\n        strings.createdQuestionsTrueFalseOne,\n        loadedQuestions\n      );\n      // }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForTrueFalseOneMixed = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n      const alfaOneDataBaseMixed = await cache.get(\n        strings.localDatabaseTrueFalseMixedOne\n      );\n      if (!alfaOneDataBaseMixed) {\n        await cache.set(\n          strings.localDatabaseTrueFalseMixedOne,\n          shuffledQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForTrueFalseOne = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseOne.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport cache from \"../../../utils/cache\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForTrueFalseTwo = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForTrueFalseTwo.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.100-199.json?auth=${token}`;\n        }\n      }\n      // console.log('createQuestionForMultiTwo', questionsArray.length);\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForTrueFalseTwo = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForTrueFalseTwo = (maxIndex: number,\n  trueFalse_useTimer: [boolean | 'created']) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDatabaseTrueFalseTwo = await cache.get(\n        strings.localDatabaseTrueFalseTwo\n      );\n      if (!localDatabaseTrueFalseTwo) {\n        await cache.set(\n          strings.localDatabaseTrueFalseTwo,\n          acceptedQuestions\n        );\n      }\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      // if (trueFalse_useTimer && trueFalse_useTimer !== \"created\") {\n      await cache.set(strings.questionsTrueFalseTwo, shuffledQuestions);\n      // }\n      if (!trueFalse_useTimer) {\n        await cache.set(\n          strings.questionsTrueFalseTwoNoTimer,\n          shuffledQuestions\n        );\n      }\n      // if (trueFalse_useTimer === \"created\") {\n      await cache.set(\n        strings.createdQuestionsTrueFalseTwo,\n        loadedQuestions\n      );\n      // }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\nexport const fetchQuestionsForTrueFalseTwoMixed = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        // console.log('question', question.accepted);\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      const alfaTwoDataBaseMixed = await cache.get(\n        strings.localDatabaseTrueFalseMixedTwo\n      );\n\n      if (!alfaTwoDataBaseMixed) {\n        await cache.set(\n          strings.localDatabaseTrueFalseMixedTwo,\n          shuffledQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForTrueFalseTwo = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseTwo.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport cache from \"../../../utils/cache\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForTrueFalseThree = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForTrueFalseThree.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForTrueFalseThree = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForTrueFalseThree = (maxIndex: number,\n  trueFalse_useTimer: [boolean | 'created']\n) => {\n  console.log(\"fetchQuestionsForTrueFalseThree\");\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const localDatabaseTrueFalseThree = await cache.get(\n        strings.localDatabaseTrueFalseThree\n      );\n      if (!localDatabaseTrueFalseThree) {\n        await cache.set(\n          strings.localDatabaseTrueFalseThree,\n          acceptedQuestions\n        );\n      }\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      // if (trueFalse_useTimer && trueFalse_useTimer !== \"created\") {\n      await cache.set(strings.questionsTrueFalseThree, shuffledQuestions);\n      // }\n      if (!trueFalse_useTimer) {\n        await cache.set(\n          strings.questionsTrueFalseThreeNoTimer,\n          shuffledQuestions\n        );\n      }\n      // if (trueFalse_useTimer === \"created\") {\n      await cache.set(\n        strings.createdQuestionsTrueFalseThree,\n        loadedQuestions\n      );\n      // }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\nexport const fetchQuestionsForTrueFalseThreeMixed = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n      // console.log('questResData', questResData);\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      const alfaThreeDataBaseMixed = await cache.get(\n        strings.localDatabaseTrueFalseMixedThree\n      );\n      if (!alfaThreeDataBaseMixed) {\n        await cache.set(\n          strings.localDatabaseTrueFalseMixedThree,\n          shuffledQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForTrueFalseThree = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseThree.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import question, { Question } from \"../../../models/question\";\nimport shuffle from \"../../../utils/shuffle\";\nimport deleteQuestion from \"../../../utils/deleteQuestion\";\nimport cache from \"../../../utils/cache\";\nimport strings from \"../../../constants/strings\";\n\nexport const createQuestionForTrueFalseFour = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      let questionsArray = [];\n      // First fetch the first group and check if it's full, i.e. 100\n      const res = await fetch(\n        \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.json\"\n      );\n      const resD = await res.json();\n      for (const key in resD) {\n        questionsArray.push(resD[key]);\n      }\n\n      let UriForQuestions = \"\";\n      // If first group is not full then upload there the question etc.\n      if (questionsArray.length <= 99) {\n        UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.json?auth=${token}`;\n      } else {\n        questionsArray = [];\n        const res = await fetch(\n          \"https://en-touto-nika.firebaseio.com///questionsForTrueFalseFour.100-199.json\"\n        );\n        const resD = await res.json();\n        for (const key in resD) {\n          questionsArray.push(resD[key]);\n        }\n        if (99 < questionsArray.length || questionsArray.length <= 199) {\n          UriForQuestions = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.100-199.json?auth=${token}`;\n        }\n      }\n\n      const index = questionsArray.length;\n      // testing\n      // const response = await fetch(`https://en-touto-nika.firebaseio.com//questions.json`, {\n      const postQuestionResponse = await fetch(UriForQuestions, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted,\n          index: index,\n          categoryIds,\n          //testing\n          // ownerId: 'eeR9esY0l8OxcxJPPA1Gp4T5Xsy1',\n          ownerId: userId,\n          title,\n          answer,\n          source,\n          right_choice,\n          hint,\n        }),\n      });\n      if (!postQuestionResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η δημιουργία νέας ερώτησης δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const updateQuestionForTrueFalseFour = (\n  accepted: boolean,\n  title: string,\n  categoryIds: string,\n  answer: string,\n  source: string,\n  right_choice: string,\n  hint: string,\n  index: number\n) => {\n  return async () => {\n    try {\n      const { token, userId } = await cache.get(strings.userData);\n\n      // Use index to find edited question in the according group.\n      let URI_forPatching = ``;\n      if (index <= 99) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour/${userId}.json?auth=${token}`;\n      } else if (99 < index || index <= 199) {\n        URI_forPatching = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.100-199/${userId}.json?auth=${token}`;\n      }\n\n      // testing\n      // const response = await fetch(\n      // `https://en-touto-nika.firebaseio.com//questions/eeR9esY0l8OxcxJPPA1Gp4T5Xsy1.json?`,\n      // {\n      const response = await fetch(URI_forPatching, {\n        method: \"PATCH\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          accepted: false,\n          title,\n          categoryIds,\n          answer,\n          source,\n          right_choice,\n          hint,\n          index,\n        }),\n      });\n\n      if (!response.ok) {\n        throw new Error(\n          \"Δυστυχώς η ανανέωση των πληροφωριών της ερωτήσεως δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const fetchQuestionsForTrueFalseFour =\n  (maxIndex: number,\n    trueFalse_useTimer: [boolean | 'created']\n  ) => {\n    return async (dispatch: Function) => {\n      try {\n        // Use maxIndex (of last answered question) to load questions from according group.\n        let URI = \"\";\n        if (maxIndex <= 99) {\n          URI =\n            \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.json\";\n        } else if (99 < maxIndex || maxIndex <= 199) {\n          URI =\n            \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.100-199.json\";\n        }\n        const questionsResponse = await fetch(URI);\n\n        // Check before unpack the response body\n        if (!questionsResponse.ok) {\n          throw new Error(\n            \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n          );\n        }\n        const questResData = await questionsResponse.json();\n\n        const loadedQuestions = [];\n        for (const key in questResData) {\n          loadedQuestions.push(\n            new (question as any)({\n              accepted: questResData[key].accepted,\n              index: questResData[key].index, // for keeping the choice in cartScreen\n              id: key,\n              categoryIds: questResData[key].categoryIds,\n              ownerId: questResData[key].ownerId,\n              title: questResData[key].title,\n              source: questResData[key].source,\n              answer: questResData[key].answer,\n              right_choice: questResData[key].right_choice,\n              hint: questResData[key].hint,\n            })\n          );\n        }\n        let acceptedQuestions: Array<Question> = [];\n        loadedQuestions.forEach((question) => {\n          if (question.accepted) {\n            acceptedQuestions.push(question);\n          }\n        });\n\n        const localDatabaseTrueFalseFour = await cache.get(\n          strings.localDatabaseTrueFalseFour\n        );\n        if (!localDatabaseTrueFalseFour) {\n          await cache.set(\n            strings.localDatabaseTrueFalseFour,\n            acceptedQuestions\n          );\n        }\n\n        await cache.set(\n          strings.createdQuestionsTrueFalseFour,\n          loadedQuestions\n        );\n\n        const shuffledQuestions = shuffle(acceptedQuestions);\n\n        // if (trueFalse_useTimer && trueFalse_useTimer !== \"created\") {\n        // For checking in ...QuestionDetails if alfaQuestions are fetched and saved in cache.\n        await cache.set(strings.questionsTrueFalseFour, shuffledQuestions);\n        // }\n        if (!trueFalse_useTimer) {\n          await cache.set(\n            strings.questionsTrueFalseFourNoTimer,\n            shuffledQuestions\n          );\n        }\n        // if (trueFalse_useTimer === \"created\") {\n        await cache.set(\n          strings.createdQuestionsTrueFalseFour,\n          loadedQuestions\n        );\n        // }\n      } catch (err) {\n        // send to custom analytics server\n        throw err;\n      }\n    };\n  };\n\nexport const fetchQuestionsForTrueFalseFourMixed = (maxIndex: number) => {\n  return async () => {\n    try {\n      // Use maxIndex (of last answered question) to load questions from according group.\n      let URI = \"\";\n      if (maxIndex <= 99) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.json\";\n      } else if (99 < maxIndex || maxIndex <= 199) {\n        URI =\n          \"https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.100-199.json\";\n      }\n      const questionsResponse = await fetch(URI);\n\n      // Check before unpack the response body\n      if (!questionsResponse.ok) {\n        throw new Error(\n          \"Δυστυχώς η φόρτωση των ερωτήσεων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n      }\n      const questResData = await questionsResponse.json();\n\n      const loadedQuestions = [];\n      for (const key in questResData) {\n        loadedQuestions.push(\n          new (question as any)({\n            accepted: questResData[key].accepted,\n            index: questResData[key].index, // for keeping the choice in cartScreen\n            id: key,\n            categoryIds: questResData[key].categoryIds,\n            ownerId: questResData[key].ownerId,\n            title: questResData[key].title,\n            source: questResData[key].source,\n            answer: questResData[key].answer,\n            right_choice: questResData[key].right_choice,\n            hint: questResData[key].hint,\n          })\n        );\n      }\n\n      let acceptedQuestions: Array<Question> = [];\n      loadedQuestions.forEach((question) => {\n        if (question.accepted) {\n          acceptedQuestions.push(question);\n        }\n      });\n\n      const shuffledQuestions = shuffle(acceptedQuestions);\n\n      const alfaFourDataBaseMixed = await cache.get(\n        strings.localDatabaseTrueFalseMixedFour\n      );\n\n      if (!alfaFourDataBaseMixed) {\n        await cache.set(\n          strings.localDatabaseTrueFalseMixedFour,\n          shuffledQuestions\n        );\n      }\n    } catch (err) {\n      // send to custom analytics server\n      throw err;\n    }\n  };\n};\n\nexport const deleteQuestionForTrueFalseFour = (\n  createCategoryId: string,\n  questionId: string,\n  index: number\n) => {\n  return async () => {\n    const { token } = await cache.get(strings.userData);\n    const uri99 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour/${questionId}.json?auth=${token}`;\n    const uri_199 = `https://en-touto-nika.firebaseio.com//questionsForTrueFalseFour.100-199/${questionId}.json?auth=${token}`;\n    await deleteQuestion(createCategoryId, index, uri99, uri_199);\n  };\n};\n","import { useCallback, useEffect, useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\n\nimport cache from \"../utils/cache\";\nimport * as questionsActions from \"../store/actions/questions\";\nimport strings from \"../constants/strings\";\n\nconst maxIndex = 0;\n\nconst useGetQuestionsList = (\n  oneIsTrue: boolean,\n  twoIsTrue: boolean,\n  threeIsTrue: boolean,\n  fourIsTrue: boolean,\n  gameType: string\n) => {\n  const [categoryIsChosen, setCategoryIsChosen] = useState(false);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState('');\n\n  const dispatch = useDispatch();\n\n  const getQuestionsFromServer = useCallback(async (category: string) => {\n    let action;\n    if (gameType === \"Multi\") {\n      if (category === \"check_one\")\n        action = questionsActions.fetchQuestionsForMixedOne(maxIndex);\n      if (category === \"check_two\")\n        action = questionsActions.fetchQuestionsForMixedTwo(maxIndex);\n      if (category === \"check_three\")\n        action = questionsActions.fetchQuestionsForMixedThree(maxIndex);\n      if (category === \"check_four\")\n        action = questionsActions.fetchQuestionsForMixedFour(maxIndex);\n    } else if (gameType === \"TrueFalse\") {\n      if (category === \"check_oneTF\")\n        action = questionsActions.fetchQuestionsForTrueFalseOneMixed(maxIndex);\n      if (category === \"check_twoTF\")\n        action = questionsActions.fetchQuestionsForTrueFalseTwoMixed(maxIndex);\n      if (category === \"check_threeTF\")\n        action = questionsActions.fetchQuestionsForTrueFalseThreeMixed(\n          maxIndex\n        );\n      if (category === \"check_fourTF\")\n        action = questionsActions.fetchQuestionsForTrueFalseFourMixed(maxIndex);\n    }\n\n    setError('');\n    setIsLoading(true);\n    try {\n      await dispatch(action);\n      setIsLoading(false);\n    } catch (error) {\n      console.log(error);\n      setIsLoading(false);\n    }\n    setIsLoading(false);\n  }\n    , [dispatch, gameType]);\n\n  const checkHandler = useCallback(async (category: string, localDatabase: string) => {\n    setCategoryIsChosen(true);\n    // Save status of checkbox in AsyncStorage.\n    await cache.set(category, true);\n    // Try to get questions from AsyncStorage.\n    const localDB = await cache.get(localDatabase);\n    !localDB && getQuestionsFromServer(category);\n  }, [getQuestionsFromServer])\n\n  useEffect(() => {\n    if (gameType === \"Multi\") {\n      if (oneIsTrue)\n        checkHandler(\"check_one\", strings.localDataBaseMultiMixedOne);\n      if (!oneIsTrue) (async () => await cache.remove(\"check_one\"))();\n      if (twoIsTrue)\n        checkHandler(\"check_two\", strings.localDataBaseMultiMixedTwo);\n      if (!twoIsTrue) (async () => await cache.remove(\"check_two\"))();\n      if (threeIsTrue)\n        checkHandler(\"check_three\", strings.localDataBaseMultiMixedThree);\n      if (!threeIsTrue) (async () => await cache.remove(\"check_three\"))();\n      if (fourIsTrue)\n        checkHandler(\"check_four\", strings.localDataBaseMultiMixedFour);\n      if (!fourIsTrue) (async () => await cache.remove(\"check_four\"))();\n    } else if (gameType === \"TrueFalse\") {\n      if (oneIsTrue)\n        checkHandler(\"check_oneTF\", strings.localDatabaseTrueFalseMixedOne);\n      if (!oneIsTrue) (async () => await cache.remove(\"check_oneTF\"))();\n      if (twoIsTrue)\n        checkHandler(\"check_twoTF\", strings.localDatabaseTrueFalseMixedTwo);\n      if (!twoIsTrue) (async () => await cache.remove(\"check_twoTF\"))();\n      if (threeIsTrue)\n        checkHandler(\n          \"check_threeTF\",\n          strings.localDatabaseTrueFalseMixedThree\n        );\n      if (!threeIsTrue) (async () => await cache.remove(\"check_threeTF\"))();\n      if (fourIsTrue)\n        checkHandler(\n          \"check_fourTF\",\n          strings.localDatabaseTrueFalseMixedFour\n        );\n      if (!fourIsTrue) (async () => await cache.remove(\"check_fourTF\"))();\n    }\n  }, [oneIsTrue, twoIsTrue, threeIsTrue, fourIsTrue, gameType, checkHandler]);\n\n  return {\n    categoryIsChosen,\n    isLoading,\n  };\n};\n\nexport default useGetQuestionsList;\n","import { useEffect, useState, useCallback } from \"react\";\nimport { useDispatch } from \"react-redux\";\n\nimport * as filtersActions from \"../store/actions/filters\";\nimport useGetQuestionsList from \"./useGetQuestionsList\";\nimport cache from \"../utils/cache\";\nimport strings from \"../constants/strings\";\n\nconst useSaveCategory = (gameType: string) => {\n  const dispatch = useDispatch();\n  // They run when a checkbox is touched\n  const [oneIsTrue, setOneIsTrue] = useState(false);\n  const [twoIsTrue, setTwoIsTrue] = useState(false);\n  const [threeIsTrue, setThreeIsTrue] = useState(false);\n  const [fourIsTrue, setFourIsTrue] = useState(false);\n\n  // For checking if we have filters on the server so we set their state from there...\n  const [filtersAreApplied, setFiltersAreApplied] = useState(false);\n\n  // Gets updated everytime we set a filter, so we delete their previous state\n  const [deleteFilters, setDeleteFilters] = useState(false);\n\n  const { categoryIsChosen, isLoading } = useGetQuestionsList(\n    oneIsTrue,\n    twoIsTrue,\n    threeIsTrue,\n    fourIsTrue,\n    gameType\n  );\n\n  const loadFilters = useCallback(async () => {\n    // We set 'categoriesFilters' in store/actions in uploadCategoriesFilters function\n    const savedFilters = await cache.get(strings.categoriesFilters);\n    // const savedFilters = JSON.parse(categoriesFilters);\n\n    let applySavedFilters = false;\n    for (const key in savedFilters) {\n      applySavedFilters = savedFilters[key].filtersAreApplied;\n      // If we have savedFilters and we didn't press a checkbox then...\n      if (applySavedFilters && !deleteFilters) {\n        setOneIsTrue(savedFilters[key].one);\n        setTwoIsTrue(savedFilters[key].two);\n        setThreeIsTrue(savedFilters[key].three);\n        setFourIsTrue(savedFilters[key].four);\n      }\n    }\n\n    // Get state of filters to send them to server\n    const appliedFilters = {\n      one: oneIsTrue,\n      two: twoIsTrue,\n      three: threeIsTrue,\n      four: fourIsTrue,\n      filtersAreApplied: filtersAreApplied,\n    };\n\n    // If a checkbox is touched then 'deleteFilters' will be true.\n    if (deleteFilters) {\n      await dispatch(filtersActions.deletePreviousCategoriesFilters(gameType));\n      await dispatch(\n        filtersActions.uploadCategoriesFilters(gameType, appliedFilters)\n      );\n    }\n  }, [\n    oneIsTrue,\n    twoIsTrue,\n    threeIsTrue,\n    fourIsTrue,\n    setOneIsTrue,\n    setTwoIsTrue,\n    setThreeIsTrue,\n    setFourIsTrue,\n    deleteFilters,\n    filtersAreApplied,\n    dispatch,\n    gameType\n  ]);\n\n  // loadFilters initially...\n  useEffect(() => {\n    const getFilters = async () => {\n      await dispatch(filtersActions.fetchCategoriesFilters(gameType));\n      loadFilters();\n    };\n    getFilters();\n  }, [loadFilters, dispatch, gameType]);\n\n  const saveOne = () => {\n    setOneIsTrue(!oneIsTrue);\n    setDeleteFilters(true);\n    setFiltersAreApplied(true);\n  };\n  const saveTwo = () => {\n    setTwoIsTrue(!twoIsTrue);\n    setDeleteFilters(true);\n    setFiltersAreApplied(true);\n  };\n  const saveThree = () => {\n    setThreeIsTrue(!threeIsTrue);\n    setDeleteFilters(true);\n    setFiltersAreApplied(true);\n  };\n  const saveFour = () => {\n    setFourIsTrue(!fourIsTrue);\n    setDeleteFilters(true);\n    setFiltersAreApplied(true);\n  };\n  return {\n    oneIsTrue,\n    twoIsTrue,\n    threeIsTrue,\n    fourIsTrue,\n    saveOne,\n    saveTwo,\n    saveThree,\n    saveFour,\n    categoryIsChosen,\n    isLoading,\n  };\n};\n\nexport default useSaveCategory;\n","import '../styles/UI/checkbox.css';\n\nexport interface CheckBoxProps {\n  text: string,\n  checked: boolean,\n  onChange: React.ChangeEventHandler<HTMLInputElement>,\n  // onClick: Function\n}\n\nconst CheckBox: React.SFC<CheckBoxProps> = (props: CheckBoxProps) => {\n  return (\n    <div className='checkbox' >\n      <label className='container' >\n        <span className='checkbox-label' >\n          {props.text}\n        </span>\n        <input type=\"checkbox\" checked={props.checked} onChange={props.onChange} />\n        <span className='checkmark' ></span>\n      </label>\n    </div>);\n}\n\nexport default CheckBox;","import { useState } from 'react';\nimport '../../styles/UI/custom-modal.css';\n\nimport Button from \"./Button\";\n\ninterface CustomModalProps {\n  textOne: string,\n  textTwo: string,\n  buttonOneTitle: string,\n  buttonTwoTitle: string,\n  onClickOne: Function,\n  onClickTwo: Function,\n  style?: any\n}\n\nconst CustomModal = ({\n  textOne,\n  textTwo,\n  buttonOneTitle,\n  buttonTwoTitle,\n  onClickOne,\n  onClickTwo,\n  style,\n}: CustomModalProps) => {\n  const [hover, setHover] = useState(false);\n\n  const handleHover = () => {\n    setHover(!hover)\n  }\n  return (\n    <article className='custom-modal' style={style}>\n      <section className='custom-modal__container' >\n        <p className='custom-modal__text' >{textOne}</p>\n        <p className='custom-modal__text' >{textTwo}</p>\n        <div className='custom-modal__buttons-container' >\n          <Button\n            style={{ width: 120, margin: 30 }}\n            disabled={false}\n            title={buttonOneTitle}\n            onClick={onClickOne}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n          <Button\n            style={{ width: 120, margin: 30 }}\n            disabled={false}\n            title={buttonTwoTitle}\n            onClick={onClickTwo}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n        </div>\n      </section>\n    </article>\n  );\n};\n\n\nexport default CustomModal;\n","import { useState, useEffect } from \"react\";\nimport { RootStateOrAny, useDispatch, useSelector } from \"react-redux\";\nimport { useHistory } from 'react-router-dom';\n\nimport useSaveCategory from \"../../../hooks/useSaveCategory\";\nimport nav from \"../../../constants/nav\";\nimport strings from \"../../../constants/strings\";\n\nimport cache from \"../../../utils/cache\";\n\nimport CheckBox from \"../../../components/CheckBox\";\nimport Button from \"../../../components/UI/Button\";\nimport '../../../styles/game/mix/categories.css';\nimport { gameOn } from \"../../../store/actions/game\";\nimport CustomModal from \"../../../components/UI/CustomModal\";\n\nconst Categories = () => {\n  const history = useHistory();\n  const dispatch = useDispatch();\n  const [showModal, setShowModal] = useState(false);\n\n  const userIsLoggedIn = localStorage.getItem(strings.userData);\n  const gameType = useSelector((state: RootStateOrAny) => state.game.id);\n  const timer = useSelector((state: RootStateOrAny) => state.game.timer);\n\n  // useSaveCategory\n  const {\n    oneIsTrue,\n    twoIsTrue,\n    threeIsTrue,\n    fourIsTrue,\n    saveOne,\n    saveTwo,\n    saveThree,\n    saveFour,\n    // isLoading,\n  } = useSaveCategory(gameType);\n\n  const categoryIsChosen = oneIsTrue || twoIsTrue || threeIsTrue || fourIsTrue;\n\n  // TODO: not needed anymore\n  // keep this in case user \n  // comes back from the game\n  // useEffect(() => {\n  //   dispatch(gameOn(false));\n  // }, [dispatch]);\n\n  useEffect(() => {\n    if (!userIsLoggedIn) {\n      setShowModal(true)\n    }\n  }, [userIsLoggedIn])\n\n  const startMixGame = async (\n    gameType: string,\n    timer: boolean\n  ) => {\n    await dispatch(gameOn(true));\n    if (gameType === \"Multi\") {\n      if (timer) {\n        await cache.set(strings.useTimerMultiMixed, true);\n        history.replace(nav.mixMultiGameWithTimer)\n      } else {\n        await cache.set(strings.useTimerMultiMixed, false);\n        history.replace(nav.mixMultiGameNoTimer)\n      }\n    } else if (gameType === \"TrueFalse\") {\n      if (timer) {\n        await cache.set(strings.useTimerTrueFalseMixed, true);\n        history.replace(nav.mixTrueFalseGameWithTimer)\n      } else {\n        await cache.set(strings.useTimerTrueFalseMixed, false);\n        history.replace(nav.mixTrueFalseGameNoTimer)\n      }\n    }\n  };\n\n  const moveToWelcome = () => {\n    setShowModal(false);\n    history.replace(nav.auth)\n  }\n\n  const hideModal = () => {\n    setShowModal(false);\n  }\n\n  // // TODO: add content\n  // if (!userIsLoggedIn) {\n  //   return (\n  //     <div></div>\n  //   );\n  // }\n\n  // // TODO: add content\n  // if (isLoading && userIsLoggedIn) {\n  //   return <div></div>\n  // }\n\n  return (\n    <section className='mix-categories' >\n      <h4 className='mix-categories__title' > ΕΠΙΛΟΓΗ ΚΑΤΗΓΟΡΙΩΝ</h4>\n      <div className={`mix-categories__container`} >\n        <div className='checkboxes-icon-container' >\n          <section className='mix-categories__checkboxes'>\n            <CheckBox checked={oneIsTrue} onChange={saveOne} text=\"Καινή Διαθήκη\" />\n            <CheckBox\n              checked={twoIsTrue}\n              onChange={saveTwo}\n              text=\"Παλαιά Διαθήκη\"\n            />\n            <CheckBox checked={threeIsTrue} onChange={saveThree} text=\"Συναξάρι\" />\n            <CheckBox\n              checked={fourIsTrue}\n              onChange={saveFour}\n              text=\"Αγιοπνευματική ζωή\"\n            />\n          </section>\n          <div className='icon-container'>\n            <img\n              alt='Theotokos icon'\n              src=\"assets/panagia-glykofilousa.jpg\"\n            />\n          </div>\n        </div>\n        <div className='start-button'>\n          <Button\n            disabled={!categoryIsChosen}\n            title=\"Εκκίνηση\"\n            onClick={() => {\n              startMixGame(gameType, timer);\n            }}\n          />\n        </div>\n      </div>\n      {showModal ? <CustomModal\n        textOne='Δεν έχετε κάνει εγγραφή'\n        textTwo='Προκειμένου να επιλέξετε κατηγορίες, χρειάζεται να κάνετε εγγραφή.'\n        buttonOneTitle='Εγγραφή'\n        buttonTwoTitle='Εντάξει'\n        onClickOne={moveToWelcome}\n        onClickTwo={hideModal}\n      /> : null}\n    </section>\n  );\n};\n\n\nexport default Categories;","import '../../../styles/game/mix/mix-choose-categories.css';\nimport Categories from './Categories';\n\nconst MixChooseCategories = () => {\n  return (\n    <div className='mix-choose-categories'>\n      <Categories />\n    </div>\n  )\n}\nexport default MixChooseCategories;","import '../../../styles/game/multi/multi-game-no-timer.css';\n\nconst MultiGameNoTimer = () => {\n  return (\n    <div>\n      MultiGameNoTimer\n\n    </div>\n  )\n}\nexport default MultiGameNoTimer;","\nimport cache from \"./cache\";\nimport strings from \"../constants/strings\";\nimport { store } from \"../store/configureStore\";\n\nconst getTotalPointsMixed = async (\n  totalPoints: number,\n  setTotalPoints: Function,\n  gameType: string\n) => {\n  let storedTotalPoints = 0;\n\n  gameType === \"Multi\"\n    ? (storedTotalPoints = store.getState().game.pointsMultiMixed)\n    : (storedTotalPoints = store.getState().game.pointsTrueFalseMixed);\n\n  if (storedTotalPoints) {\n    setTotalPoints(storedTotalPoints);\n  } else {\n    setTotalPoints(totalPoints);\n  }\n};\n\nexport default getTotalPointsMixed;","import cache from \"./cache\";\nimport strings from \"../constants/strings\";\n\nconst updateNumOfTotalQuestionsMixed = async (\n  gameType: string,\n  numOfTotalQuestions: number,\n  setNumOfTotalQuestions: Function\n) => {\n  let numOfTotQ = 0;\n  let newValue = 0;\n\n  gameType === \"Multi\"\n    ? (numOfTotQ = await cache.get(strings.numOfTotQuestionsMultiMixed))\n    : (numOfTotQ = await cache.get(strings.numOfTotQuestionsTrueFalseMixed));\n  if (!!numOfTotQ) {\n    newValue = +numOfTotQ + 1;\n    setNumOfTotalQuestions(newValue);\n    saveCache(gameType, newValue);\n  } else {\n    // newValue = numOfTotalQuestions + 1;\n    // setNumOfTotalQuestions(newValue);\n    saveCache(gameType, numOfTotalQuestions);\n  }\n};\n\nconst saveMulti = async (value: number) => {\n  await cache.remove(strings.numOfTotQuestionsMultiMixed);\n  await cache.set(strings.numOfTotQuestionsMultiMixed, String(value));\n};\n\nconst saveTrueFalse = async (newValue: number) => {\n  await cache.remove(strings.numOfTotQuestionsTrueFalseMixed);\n  await cache.set(strings.numOfTotQuestionsTrueFalseMixed, String(newValue));\n};\n\nconst saveCache = async (gameType: string, value: number) => {\n  if (gameType === \"Multi\") {\n    saveMulti(value);\n  } else {\n    saveTrueFalse(value);\n  }\n};\nexport default updateNumOfTotalQuestionsMixed;","import { useCallback, useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\n\nimport strings from \"../constants/strings\";\n\nimport * as questionsActions from \"../store/actions/questions\";\n\nimport cache from \"../utils/cache\";\nimport getTotalPointsMixed from \"../utils/getTotalPointsMixed\";\n// import getTotalTimeLeft from \"../utils/getTotalTimeLeftTrueFalse\";\nimport updateNumOfTotalQuestionsMixed from \"../utils/updateNumOfTotalQuestionsMixed\";\n\nconst useLoadQuestionsMixedMulti = (timer: boolean, gameType: string) => {\n  const dispatch = useDispatch();\n  const [loadQuestionsError, setLoadQuestionsError] = useState(null); // error initially is undefined!\n  // const [totalTimeLeft, setTotalTimeLeft] = useState(0);\n  const [totalPoints, setTotalPoints] = useState(0);\n  const [numOfTotalQuestions, setNumOfTotalQuestions] = useState(0); // for each stadium\n  const [numOfDownloadedQuestions, setNumOfDownloadedQuestions] = useState(0);\n  const [selectedQuestion, setSelectedQuestion] = useState(null);\n  const [stadiumIsFinished, setStadiumIsFinished] = useState(false);\n\n\n  const loadQuestions = useCallback(async () => {\n    // const getTotalTimeLeft = async () => {\n    //   if (timer) {\n    //     let totalTimeLeft = await cache.get(strings.totalTimeLeftMultiMixed);\n    //     if (!totalTimeLeft) totalTimeLeft = 0;\n    //     else setTotalTimeLeft(parseInt(totalTimeLeft));\n    //   }\n    // }\n\n\n    try {\n      if (timer) {\n        const mixGameIsOn = await cache.get(strings.mixGameIsOnMulti);\n        !mixGameIsOn && (await cache.set(strings.mixGameIsOnMulti, true));\n      } else {\n        const mixGameIsOn = await cache.get(strings.mixGameIsOnMultiNoTimer);\n        !mixGameIsOn && (await cache.set(strings.mixGameIsOnMultiNoTimer, true));\n      }\n\n      setLoadQuestionsError(null);\n\n      updateNumOfTotalQuestionsMixed(\n        gameType,\n        numOfTotalQuestions,\n        setNumOfTotalQuestions\n      );\n\n      getTotalPointsMixed(totalPoints, setTotalPoints, gameType);\n\n      // timer && getTotalTimeLeft();\n\n      let questions = await cache.get(strings.questionsMultiMixed);\n\n      // In case game just starts we fetch the questions and store them to AsyncStorage\n      if (!questions) {\n        setNumOfTotalQuestions(1);\n        setTotalPoints(0);\n        if (timer) {\n          await cache.remove(strings.min);\n          await cache.remove(strings.sec);\n        }\n\n        await dispatch(\n          questionsActions.fetchQuestionsMultiMixed()\n        );\n        questions = await cache.get(strings.questionsMultiMixed);\n      }\n\n      if (questions) {\n        setNumOfDownloadedQuestions(questions.length);\n\n        // Remove the old set and save the new one with one less question\n        const newSelectedQuestion = questions.splice(0, 1);\n        await cache.remove(strings.questionsMultiMixed);\n\n        // If there is a question store it...\n        if (questions.length > 0 || newSelectedQuestion.length === 1) {\n          await cache.set(strings.questionsMultiMixed, questions);\n          setSelectedQuestion(newSelectedQuestion.pop());\n        } else if (questions.length === 0 || newSelectedQuestion.length === 0) {\n          setStadiumIsFinished(true);\n          await cache.remove(strings.numOfTotQuestionsMultiMixed);\n          await cache.remove(strings.questionsMultiMixed);\n        }\n      }\n    } catch (err) {\n      console.log(err);\n      setLoadQuestionsError(err.message);\n    }\n  }, [dispatch, gameType, numOfTotalQuestions, timer, totalPoints]);\n\n  return {\n    loadQuestions,\n    loadQuestionsError,\n    numOfDownloadedQuestions,\n    numOfTotalQuestions,\n    selectedQuestion,\n    setNumOfTotalQuestions,\n    setStadiumIsFinished,\n    setTotalPoints,\n    stadiumIsFinished,\n    totalPoints,\n  };\n};\n\nexport default useLoadQuestionsMixedMulti;","import cache from \"./cache\";\nimport strings from \"../constants/strings\";\n\nconst saveGradeToCache = async (totalPoints: number) => {\n  let sum = 0;\n  let points = await cache.get(strings.savedPoints);\n  if (!points) {\n    await cache.set(strings.savedPoints, +totalPoints);\n  } else if (!!points) {\n    sum = +points + +totalPoints;\n    await cache.remove(strings.savedPoints);\n    cache.set(strings.savedPoints, +sum);\n  }\n};\n\nexport default saveGradeToCache;","import * as mixedData from \"./mixedData\";\nimport * as alfaOneData from \"./alfaOneData\";\n\nconst fetchAllUsersData = mixedData.fetchAllUsersData;\nconst saveDataToAllUsersData = mixedData.saveDataToAllUsersData;\n\nexport { fetchAllUsersData };\nexport { saveDataToAllUsersData };\n\nconst saveData = alfaOneData.saveData;\n\nexport { saveData };\n\n// We need to do the above work around untill React-Native -v 0.61\n// https://github.com/facebook/react-native/issues/22592\n\n// export * from './mixedData'\n// export * from './alfaData'\n// export * from './betaData'\n// export * from './gammaData'\n// export * from './deltaData'\n// export * from './alfaOneData'\n// export * from './twoData'\n// export * from './threeData'\n// export * from './fourData'\n// export * from './fiveData'\n// export * from './sixData'\n// export * from './sevenData'\n// export * from './eightData'\n// export * from './nineData'\n// export * from './tenData'\n","\nexport const saveData = (email: string, totalPoints: number) => {\n  return async (dispatch: Function, getState: Function) => {\n    try {\n      const userId = getState().auth.userId;\n      const token = getState().auth.token;\n      const date = new Date();\n\n      // First get the old grade to check which one to save\n      const response = await fetch(\n        `https://en-touto-nika.firebaseio.com/All_Users_Data/${userId}.json`\n      );\n\n      // check before unpack the response body\n      if (!response.ok) {\n        alert(\n          \"Δυστυχώς η ανάκτηση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n\n        // throw new Error(\n        //   \"Δυστυχώς η ανάκτηση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        // );\n\n      }\n\n      const resData = await response.json();\n      // Just keep on adding the points to the old ones...\n      let newTotalPoints = 0;\n      if (!resData) newTotalPoints = totalPoints;\n      else {\n        for (const key in resData) {\n          for (const item in resData[key]) {\n            if (resData[key].totalPoints) {\n              newTotalPoints = +resData[key].totalPoints + +totalPoints;\n            } else {\n              newTotalPoints = +totalPoints;\n            }\n          }\n        }\n      }\n      if (resData) {\n        const deleteAllUsersData = await fetch(\n          `https://en-touto-nika.firebaseio.com/All_Users_Data/${userId}.json?auth=${token}`,\n          {\n            method: \"DELETE\",\n          }\n        );\n        if (!deleteAllUsersData.ok) {\n          alert(\n            \"Δυστυχώς η διαγραφή της βαθμολογίας δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n          );\n\n          // throw new Error(\n          //   \"Δυστυχώς η διαγραφή της βαθμολογίας δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n          // );\n        }\n      }\n\n      const firstPostResponse = await fetch(\n        `https://en-touto-nika.firebaseio.com/All_Users_Data/${userId}.json?auth=${token}`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            totalPoints: newTotalPoints,\n            email,\n            date: date.toISOString(),\n          }),\n        }\n      );\n\n      if (!firstPostResponse.ok) {\n        alert(\n          \"Δυστυχώς η αποθήκευση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        );\n        // throw new Error(\n        //   \"Δυστυχώς η αποθήκευση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n        // );\n\n      }\n    } catch (err) {\n      // send to custom analytics server\n      // alert(\n      //   \"Δυστυχώς η αποθήκευση των δεδομένων δεν ήταν δυνατή! Παρακαλούμε ελέγξτε τη σύνδεσή σας.\"\n      // );\n      throw err;\n    }\n  };\n};\n","import cache from \"./cache\";\nimport strings from \"../constants/strings\";\n\nexport const multipleChoiceRemoveAsync = async (categoryId: string) => {\n  if (categoryId === \"c1\") {\n    await localStorage.removeItem(strings.questionsMultiOne);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiOne);\n    await localStorage.removeItem(strings.totalPointsMultiOne);\n    await localStorage.removeItem(strings.totalTimeLeftMultiOne);\n  } else if (categoryId === \"c2\") {\n    await localStorage.removeItem(strings.questionsMultiTwo);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiTwo);\n    await localStorage.removeItem(strings.totalPointsMultiTwo);\n    await localStorage.removeItem(strings.totalTimeLeftMultiTwo);\n  } else if (categoryId === \"c3\") {\n    await localStorage.removeItem(strings.questionsMultiThree);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiThree);\n    await localStorage.removeItem(strings.totalPointsMultiThree);\n    await localStorage.removeItem(strings.totalTimeLeftMultiThree);\n  } else if (categoryId === \"c4\") {\n    await localStorage.removeItem(strings.questionsMultiFour);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiFour);\n    await localStorage.removeItem(strings.totalPointsMultiFour);\n    await localStorage.removeItem(strings.totalTimeLeftMultiFour);\n  }\n  await localStorage.removeItem(strings.alfaIsTrueMulti);\n  await localStorage.removeItem(strings.betaIsTrueMulti);\n  await localStorage.removeItem(strings.gammaIsTrueMulti);\n  await localStorage.removeItem(strings.deltaIsTrueMulti);\n  await localStorage.removeItem(strings.lastQuestionSecondsMulti);\n  await localStorage.removeItem(strings.lastQuestionMinutesMulti);\n};\n\nexport const noTimerRemoveAsync = async (categoryId: string) => {\n  if (categoryId === \"c1\") {\n    await localStorage.removeItem(strings.questionsMultiOneNoTimer);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiOneNoTimer);\n    await localStorage.removeItem(strings.totalPointsMultiOneNoTimer);\n  } else if (categoryId === \"c2\") {\n    await localStorage.removeItem(strings.questionsMultiTwoNoTimer);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiTwoNoTimer);\n    await localStorage.removeItem(strings.totalPointsMultiTwoNoTimer);\n  } else if (categoryId === \"c3\") {\n    await localStorage.removeItem(strings.questionsMultiThreeNoTimer);\n    await localStorage.removeItem(\n      strings.numOfTotQuestionsMultiThreeNoTimer\n    );\n    await localStorage.removeItem(strings.totalPointsMultiThreeNoTimer);\n  } else if (categoryId === \"c4\") {\n    await localStorage.removeItem(strings.questionsMultiFourNoTimer);\n    await localStorage.removeItem(strings.numOfTotQuestionsMultiFourNoTimer);\n    await localStorage.removeItem(strings.totalPointsMultiFourNoTimer);\n  }\n  await localStorage.removeItem(strings.alfaIsTrueMulti);\n  await localStorage.removeItem(strings.betaIsTrueMulti);\n  await localStorage.removeItem(strings.gammaIsTrueMulti);\n  await localStorage.removeItem(strings.deltaIsTrueMulti);\n};\n\nexport const trueFalseRemoveAsync = async (categoryId: string) => {\n  if (categoryId === \"c1\") {\n    await localStorage.removeItem(strings.questionsTrueFalseOne);\n    await localStorage.removeItem(strings.numOfRemainQuestionsTrueFalseOne);\n    await localStorage.removeItem(strings.numOfTotQuestionsTrueFalseOne);\n    await localStorage.removeItem(strings.totalPointsTrueFalseOne);\n    await localStorage.removeItem(strings.totalTimeLeftTrueFalseOne);\n  } else if (categoryId === \"c2\") {\n    await localStorage.removeItem(strings.questionsTrueFalseTwo);\n    await localStorage.removeItem(strings.numOfRemainQuestionsTrueFalseTwo);\n    await localStorage.removeItem(strings.numOfTotQuestionsTrueFalseTwo);\n    await localStorage.removeItem(strings.totalPointsTrueFalseTwo);\n    await localStorage.removeItem(strings.totalTimeLeftTrueFalseTwo);\n  } else if (categoryId === \"c3\") {\n    await localStorage.removeItem(strings.questionsTrueFalseThree);\n    await localStorage.removeItem(\n      strings.numOfRemainQuestionsTrueFalseThree\n    );\n    await localStorage.removeItem(strings.numOfTotQuestionsTrueFalseThree);\n    await localStorage.removeItem(strings.totalPointsTrueFalseThree);\n    await localStorage.removeItem(strings.totalTimeLeftTrueFalseThree);\n  } else if (categoryId === \"c4\") {\n    await localStorage.removeItem(strings.questionsTrueFalseFour);\n    await localStorage.removeItem(strings.numOfRemainQuestionsTrueFalseFour);\n    await localStorage.removeItem(strings.numOfTotQuestionsTrueFalseFour);\n    await localStorage.removeItem(strings.totalPointsTrueFalseFour);\n    await localStorage.removeItem(strings.totalTimeLeftTrueFalseFour);\n  }\n  await localStorage.removeItem(strings.noIsChosen);\n  await localStorage.removeItem(strings.yesIsChosen);\n  await localStorage.removeItem(strings.questionsRightChoices);\n  await localStorage.removeItem(strings.indexTrueFalse);\n  await localStorage.removeItem(strings.lastQuestionSecondsTrueFalse);\n  await localStorage.removeItem(strings.lastQuestionMinutesTrueFalse);\n};\n\nexport const noTimerTrueFalseRemoveAsync = async (categoryId: string) => {\n  console.log(\"noTimerTrueFalseRemoveAsync\");\n  if (categoryId === \"c1\") {\n    await localStorage.removeItem(strings.questionsTrueFalseOneNoTimer);\n    await localStorage.removeItem(\n      strings.numOfTotQuestionsTrueFalseOneNoTimer\n    );\n    await localStorage.removeItem(\n      strings.numOfRemainQuestionsTrueFalseOneNoTimer\n    );\n    await localStorage.removeItem(strings.totalPointsTrueFalseOneNoTimer);\n  } else if (categoryId === \"c2\") {\n    await localStorage.removeItem(strings.questionsTrueFalseTwoNoTimer);\n    await localStorage.removeItem(\n      strings.numOfRemainQuestionsTrueFalseTwoNoTimer\n    );\n    await localStorage.removeItem(\n      strings.numOfTotQuestionsTrueFalseTwoNoTimer\n    );\n    await localStorage.removeItem(strings.totalPointsTrueFalseTwoNoTimer);\n  } else if (categoryId === \"c3\") {\n    await localStorage.removeItem(strings.questionsTrueFalseThreeNoTimer);\n    await localStorage.removeItem(\n      strings.numOfRemainQuestionsTrueFalseThreeNoTimer\n    );\n    await localStorage.removeItem(\n      strings.numOfTotQuestionsTrueFalseThreeNoTimer\n    );\n    await localStorage.removeItem(strings.totalPointsTrueFalseThreeNoTimer);\n  } else if (categoryId === \"c4\") {\n    await localStorage.removeItem(strings.questionsTrueFalseFourNoTimer);\n    await localStorage.removeItem(\n      strings.numOfRemainQuestionsTrueFalseFourNoTimer\n    );\n    await localStorage.removeItem(\n      strings.numOfTotQuestionsTrueFalseFourNoTimer\n    );\n    await localStorage.removeItem(strings.totalPointsTrueFalseFourNoTimer);\n  }\n  await localStorage.removeItem(strings.noIsChosen);\n  await localStorage.removeItem(strings.yesIsChosen);\n  await localStorage.removeItem(strings.questionsRightChoicesNoTimer);\n  await localStorage.removeItem(strings.indexTrueFalseNoTimer);\n};\n\n// adjust strings like the above format\nexport const removeAsyncMultiMixed = async () => {\n  console.log(\"removeAsyncMultiMixed\");\n  await localStorage.removeItem(strings.pointsTypeMultiMixed);\n  await localStorage.removeItem(strings.questionsMultiMixed);\n  await localStorage.removeItem(strings.mixGameIsOnMulti);\n  await localStorage.removeItem(strings.mixGameIsOnMultiNoTimer);\n  await localStorage.removeItem(strings.numOfTotQuestionsMultiMixed);\n  await localStorage.removeItem(strings.alfaIsTrueMultiMixed);\n  await localStorage.removeItem(strings.betaIsTrueMultiMixed);\n  await localStorage.removeItem(strings.gammaIsTrueMultiMixed);\n  await localStorage.removeItem(strings.betaIsTrueMultiMixed);\n  await localStorage.removeItem(strings.deltaIsTrueMultiMixed); // from Categories\n  // await localStorage.removeItem(strings.totalTimeLeftMultiMixed);\n  await localStorage.removeItem(strings.lastQuestionSecondsMultiMixed);\n  await localStorage.removeItem(strings.lastQuestionMinutesMultiMixed);\n};\n\n// adjust strings like the above format\nexport const removeAsyncTrueFalseMixed = async () => {\n  console.log(\"removeAsyncTrueFalseMixed\");\n  await localStorage.removeItem(strings.pointsTypeTrueFalseMixed);\n  await localStorage.removeItem(strings.questionsTrueFalseMixed);\n  await localStorage.removeItem(strings.mixGameIsOnTrueFalse);\n  await localStorage.removeItem(strings.mixGameIsOnTrueFalseNoTimer);\n  await localStorage.removeItem(strings.mixedQuestionsAreOnTrueFalse);\n  await localStorage.removeItem(strings.numOfRemainQuestionsTrueFalseMixed);\n  await localStorage.removeItem(strings.numOfTotQuestionsTrueFalseMixed);\n  await localStorage.removeItem(strings.noIsChosen);\n  await localStorage.removeItem(strings.yesIsChosen);\n  await localStorage.removeItem(strings.useTimerTrueFalseMixed); // from Categories\n  await localStorage.removeItem(strings.totalTimeLeftTrueFalseMixed);\n  await localStorage.removeItem(strings.lastQuestionSecondsTrueFalseMixed);\n  await localStorage.removeItem(strings.lastQuestionMinutesTrueFalseMixed);\n  await localStorage.removeItem(strings.indexTrueFalseMixed);\n};\n\nexport const removeChoicesfromAsyncStorage = async () => {\n  // Here we remove all choices.\n  await cache.remove(strings.alfaIsTrueMultiMixed);\n  await cache.remove(strings.betaIsTrueMultiMixed);\n  await cache.remove(strings.gammaIsTrueMultiMixed);\n  await cache.remove(strings.deltaIsTrueMultiMixed);\n\n  await cache.remove(strings.alfaIsTrueMulti);\n  await cache.remove(strings.betaIsTrueMulti);\n  await cache.remove(strings.gammaIsTrueMulti);\n  await cache.remove(strings.deltaIsTrueMulti);\n};\n","import { useEffect, useState } from \"react\";\nimport { useDispatch } from \"react-redux\";\n\nimport saveGradeToCache from \"../utils/saveGradeToCache\";\nimport * as dataActions from \"../store/actions/data\";\nimport {\n  removeAsyncMultiMixed,\n  removeAsyncTrueFalseMixed,\n  multipleChoiceRemoveAsync,\n  noTimerRemoveAsync,\n  trueFalseRemoveAsync,\n  noTimerTrueFalseRemoveAsync,\n} from \"../utils/removeAsync\";\nimport { savePoints } from \"../store/actions/game\";\nimport strings from \"../constants/strings\";\nimport { history } from \"../App\";\nimport nav from \"../constants/nav\";\nimport tryLogin from \"../utils/tryLogin\";\n\nconst useSaveStadiumResultHandler = (\n  totalPoints: number,\n  email: string,\n  userIsLogedIn: boolean,\n  gameType: string,\n  timer: boolean,\n  quit: Function,\n  categoryId: string,\n) => {\n  const dispatch = useDispatch();\n  const [isUpLoading, setIsUpLoading] = useState(false);\n  const [error, setError] = useState(); // error initially is undefined!\n\n  const onLine = navigator.onLine;\n\n  useEffect(() => {\n    // tryLogin checks if users token is valid\n    // and if not it gets a new one\n    tryLogin(setError);\n  }, []);\n\n  if (error) {\n    alert(`\n    Σφάλμα στη διαδικασία ταυτοποίησης των στοιχείων σας.\n    Παρακαλούμε ελέγξτε τη σύνδεσή σας.\n    `)\n  }\n\n  const saveStadiumResult = async () => {\n    setIsUpLoading(true);\n    if (userIsLogedIn) {\n      if (onLine) {\n        await dispatch(dataActions.saveData(email, totalPoints));\n      } else {\n        alert(\"Η βαθμολογία σας θα αποθηκευθεί στη συσκευή σας και όταν θα συνδεθείτε θα αποθηκευθεί και στη βάση δεδομένων του παιχνιδιού.\");\n        //TODO: save points to redux\n        saveGradeToCache(totalPoints);\n      }\n    }\n    quit();\n    setIsUpLoading(false);\n\n    dispatch(savePoints(0, strings.pointsTypeMultiMixed))\n\n    if (categoryId === \"MultiMixed\") {\n      await removeAsyncMultiMixed();\n    } else if (categoryId === \"TrueFalseMixed\") {\n      await removeAsyncTrueFalseMixed();\n    } else if (gameType === \"Multi\" && timer) {\n      multipleChoiceRemoveAsync(categoryId);\n    } else if (gameType === \"Multi\" && !timer) {\n      noTimerRemoveAsync(categoryId);\n    } else if (gameType === \"TrueFalse\" && timer) {\n      trueFalseRemoveAsync(categoryId);\n    } else if (gameType === \"TrueFalse\" && !timer) {\n      noTimerTrueFalseRemoveAsync(categoryId);\n    }\n    history.push(nav.home);\n\n  };\n\n  return { isUpLoading, saveStadiumResult };\n};\nexport default useSaveStadiumResultHandler;","import { RootStateOrAny, useSelector } from 'react-redux';\n\nimport strings from '../../constants/strings';\nimport '../../styles/UI/top-menu.css';\n\ninterface TopMenuProps {\n  categoryTitle: string,\n  numOfDownloadedQuestions: number,\n  numOfTotalQuestions: number,\n}\nconst TopMenu = ({\n  categoryTitle,\n  numOfDownloadedQuestions,\n  numOfTotalQuestions,\n}: TopMenuProps) => {\n  const pointsType = useSelector((state: RootStateOrAny) => state.game.pointsType);\n  const pointsMultiMixed = useSelector((state: RootStateOrAny) => state.game.pointsMultiMixed);\n  const pointsTrueFalseMixed = useSelector((state: RootStateOrAny) => state.game.pointsTrueFalseMixed);\n  let totalPoints = 0\n\n  if (pointsType === strings.pointsTypeMultiMixed)\n    totalPoints = pointsMultiMixed;\n  if (pointsType === strings.pointsTypeTrueFalseMixed)\n    totalPoints = pointsTrueFalseMixed;\n\n  return (\n    <article className='top-menu' >\n      <div className='top-menu__container' >\n        <div className='questions-container' >\n          <h4 >Ερωτήσεις</h4>\n          <h5 >\n            {numOfTotalQuestions} / {numOfDownloadedQuestions - 1}\n          </h5>\n        </div>\n        <div>\n          <h3 className='category-title' >{categoryTitle}</h3>\n          <div className='icon-container' >\n            <img\n              src=\"assets/panagia-glykofilousa.jpg\"\n              alt='icon of Theotokos'\n            />\n          </div>\n        </div>\n        <div className='right-container' >\n          <h4 >Σωστές</h4>\n          <h5 >{totalPoints}</h5>\n        </div>\n      </div>\n    </article >\n  );\n};\n\nexport default TopMenu;","import strings from '../../constants/strings';\nimport colors from '../../constants/colors';\nimport '../../styles/UI/choice-text.css';\n\nimport cache from \"../../utils/cache\";\ninterface ChoiceTextProps {\n  choiceIsMade: boolean,\n  choice: string,\n  choiceColor: any,\n  choiceLetter: string,\n  disabled: boolean,\n  choiceText: string,\n  selectedQuestion: any,\n  saveAnswer: Function,\n  setChoiceSave: Function,\n  setStyle: Function,\n}\n\nconst ChoiceText = ({\n  choiceIsMade,\n  choice,\n  choiceColor,\n  choiceLetter,\n  disabled,\n  choiceText,\n  selectedQuestion,\n  saveAnswer,\n  setChoiceSave,\n  setStyle,\n}: ChoiceTextProps) => {\n  let question = '';\n  let key: any;\n\n  for (key in selectedQuestion) {\n    if (key === choiceText)\n      question = selectedQuestion[key]\n    else if (key === choiceText)\n      question = selectedQuestion[key]\n    else if (key === choiceText)\n      question = selectedQuestion[key]\n    else if (key === choiceText)\n      question = selectedQuestion[key]\n  }\n\n  const styles = {\n    // choice: {\n    //   color: colors.maroon,\n    //   marginTop: 10,\n    //   marginBottom: 4,\n    //   textAlign: \"left\",\n    // },\n    choiceIsMade: {\n      padding: 10,\n      marginVertical: 2,\n      marginHorizontal: 2,\n      borderRadius: 10,\n      shadowColor: \"white\",\n      shadowOpacity: 0.6,\n      shadowOffset: { width: 0, height: 2 },\n      shadowRadius: 10,\n      backgroundColor: choiceColor,\n      transition: 'all 1s'\n    },\n    none: {}\n  }\n\n  return (\n    <div\n      className={`choice-text ${disabled ? 'disabled' : ''}`}\n      onClick={async () => {\n        await cache.set(choice, true);\n        setStyle(true);\n        setTimeout(() => {\n          // leave setChoiceSave inside the timeout\n          // otherwise you get problems with FakeSuspense in showQuestion\n          saveAnswer();\n          setChoiceSave(true);\n        }, 400);\n      }}\n    >\n      <div className='choice-container' >\n        <h4 className='choice-letter' >{choiceLetter}</h4>\n        <p\n          className='choice-question'\n          style={choiceIsMade ? styles.choiceIsMade : styles.none}\n        >\n          {question}\n        </p>\n      </div>\n    </div>\n  );\n};\n\n\n\n\nexport default ChoiceText;","import '../../styles/UI/line.css';\n\nconst Line = (props: any) => <div {...props.className} className='line'></div>\n\n\n\nexport default Line;","import '../../styles/UI/link-text.css';\n\nconst LinkText = (props: any) => {\n  return (\n    <div className='link-text' >\n      <h5 className='source' >Περισσότερα: </h5>\n      <p>\n        {props.children}\n      </p>\n    </div>\n  );\n};\n\n\nexport default LinkText;\n","import { MdQueuePlayNext } from 'react-icons/md'\nimport { SiGitea } from 'react-icons/si';\n\nimport Line from \"../../components/UI/Line\";\nimport LinkText from \"./LinkText\";\n\nimport nav from '../../constants/nav';\nimport '../../styles/UI/detailed-answer.css';\nimport { removeChoicesfromAsyncStorage } from '../../utils/removeAsync';\n\nconst DetailedAnswer = ({ history, selectedQuestion, onRefresh }: any) => {\n\n  const breakHandler = async () => {\n    removeChoicesfromAsyncStorage();\n    history.replace(nav.home);\n  }\n  return (\n    <section className='detailed-answer' >\n      <div className='icons-container' >\n        <SiGitea\n          onClick={breakHandler}\n          className=\"break-icon\"\n        />\n        <div onClick={() => onRefresh()} >\n          <MdQueuePlayNext className='icon-show-next' />\n        </div>\n      </div>\n      <h3 className='title' >Απάντηση</h3>\n\n      <div className='answer-text'\n        style={{ whiteSpace: 'pre-wrap' }}\n      >\n        {selectedQuestion.answer}\n      </div>\n      <div className='link' >\n        <a\n          className='link__anchor'\n          href={selectedQuestion.source}\n          rel=\"noreferrer\"\n          target='_blank'\n        >\n          {!!selectedQuestion.source ?\n            <LinkText>\n              {selectedQuestion.source.match(/(?<=www.|\\.).*(?=\\.)/g)}\n              ...\n            </LinkText> :\n            null\n          }\n        </a>\n      </div>\n      <div className='icons-container' >\n        <SiGitea\n          onClick={breakHandler}\n          className=\"break-icon\"\n        />\n        <div onClick={() => onRefresh()} >\n          <MdQueuePlayNext className='icon-show-next' />\n        </div>\n      </div>\n      <Line className='line' />\n    </section >\n  );\n};\n\n\nexport default DetailedAnswer;","import { useState, useEffect } from \"react\";\n\nconst FakeSuspense = (props: any) => {\n  const { children, delay, fallback } = props;\n  const [isShown, setIsShown] = useState(false);\n  useEffect(() => {\n    setTimeout(() => {\n      setIsShown(true);\n    }, delay);\n  }, [delay]);\n\n  return isShown ? children : fallback;\n}\n\nexport default FakeSuspense;","import { useEffect, useRef, useState } from 'react';\nimport lottie from 'lottie-web';\nimport '../styles/animations/correct.scss';\nconst playAlert = require('alert-sound-notify');\n\nexport default function CorrectAnimation(props: any) {\n  const [fadeout, setFadeout] = useState(false)\n  const container = useRef<HTMLDivElement>(null);\n  playAlert.content['correct'] = ['assets/sounds/correct.mp3'];\n\n  useEffect(() => {\n    if (container.current !== null) {\n      lottie.loadAnimation({\n        container: container.current,\n        renderer: 'svg',\n        loop: false,\n        autoplay: true,\n        animationData: require('./json/correct.json')\n      })\n    }\n\n  }, [])\n\n  useEffect(() => {\n    setTimeout(() => {\n      playAlert('correct');\n    }, 700);\n    setTimeout(() => {\n      setFadeout(true);\n    }, 3000);\n  }, [])\n\n\n\n  return (\n    <div>\n      <div ref={container}\n        className={`animation ${fadeout ? 'fade-out' : ''}`}\n      >\n      </div>\n    </div>\n  )\n}\n","import { useEffect, useRef, useState } from 'react';\nimport lottie from 'lottie-web';\nimport '../styles/animations/wrong.css';\nconst playAlert = require('alert-sound-notify');\n\nexport default function WrongAnimation(props: any) {\n  const [fadeout, setFadeout] = useState(false)\n  const container = useRef<HTMLDivElement>(null);\n  playAlert.content['wrong'] = ['assets/sounds/wrong2.wav'];\n\n  useEffect(() => {\n    if (container.current !== null) {\n      lottie.loadAnimation({\n        container: container.current,\n        renderer: 'svg',\n        loop: false,\n        autoplay: true,\n        animationData: require('./json/wrong.json')\n      })\n    }\n\n  }, [])\n\n  useEffect(() => {\n    setTimeout(() => {\n      playAlert('wrong');\n    }, 700);\n    setTimeout(() => {\n      setFadeout(true);\n    }, 3000);\n  }, [])\n\n\n\n  return (\n    <div>\n      <div ref={container}\n        className={`animation ${fadeout ? 'fade-out' : ''}`}\n      >\n      </div>\n    </div>\n  )\n}\n","import { Prompt } from 'react-router-dom'\n\nimport TopMenu from \"../UI/TopMenu\";\nimport ChoiceText from \"../UI/ChoiceText\";\nimport DetailedAnswer from \"../UI/DetailedAnswer\";\nimport { Question } from \"../../models/question\";\nimport FakeSuspense from './FakeSuspense';\nimport CorrectAnimation from '../../animations/CorrectAnimation';\nimport WrongAnimation from '../../animations/WrongAnimation';\nimport '../../styles/game/show-question.css'\n\nconst showQuestion = (\n  alfaIsTrue: string,\n  betaIsTrue: string,\n  gammaIsTrue: string,\n  deltaIsTrue: string,\n  checkAlfa: boolean,\n  checkBeta: boolean,\n  categoryId: boolean,\n  gameType: string,\n  history: any,\n  checkGamma: boolean,\n  checkDelta: boolean,\n  choiceColor: string,\n  choiceSave: boolean,\n  correctChoice: boolean,\n  saveAnswer: Function,\n  showAnswer: boolean,\n  numOfDownloadedQuestions: number,\n  numOfTotalQuestions: number,\n  onRefresh: Function,\n  selectedQuestion: Question | null,\n  quit: Function,\n  setCheckAlfa: Function,\n  setCheckBeta: Function,\n  setCheckGamma: Function,\n  setCheckDelta: Function,\n  setChoiceSave: Function,\n  setNumOfTotalQuestions: Function,\n  setShowAnswer: Function,\n  setStadiumIsFinished: Function,\n  timer: boolean,\n  totalPoints: number,\n  modalVisible: boolean,\n\n) => {\n\n  let categoryTitle = \"\";\n  if (!!selectedQuestion) {\n    if (selectedQuestion.categoryIds === \"c1\") {\n      categoryTitle = \"Καινή Διαθήκη\";\n    } else if (selectedQuestion.categoryIds === \"c2\") {\n      categoryTitle = \"Παλαιά Διαθήκη\";\n    } else if (selectedQuestion.categoryIds === \"c3\") {\n      categoryTitle = \"Συναξάρι\";\n    } else if (selectedQuestion.categoryIds === \"c4\") {\n      categoryTitle = \"Αγιοπνευματική ζωή\";\n    }\n  }\n\n  /* \n    Alerts user not to reload page while playing.\n    If user already answered the question, \n    it doesn't matter, user just moves to next question.\n   */\n  if (!choiceSave)\n    window.onbeforeunload = function () {\n      return 'Αν δεν απαντήσετε την ερώτηση θα την χάσετε! Θέλετε να εγκαταλείψετε το παιχνίδι;';\n    }\n\n  for (const key in selectedQuestion) {\n    return (\n      <article\n        className={`show-question ${!choiceSave ? 'fade-in' : ''} `}\n        style={{ width: 500 }}\n      >\n        <Prompt\n          when={!choiceSave}\n          message='Αν δεν απαντήσετε την ερώτηση θα την χάσετε! Θέλετε να εγκαταλείψετε το παιχνίδι;'\n        />\n        <TopMenu\n          categoryTitle={categoryTitle}\n          numOfDownloadedQuestions={numOfDownloadedQuestions}\n          numOfTotalQuestions={numOfTotalQuestions}\n        />\n        {choiceSave ?\n          <FakeSuspense delay={3900} fallback={correctChoice ? <CorrectAnimation /> : <WrongAnimation />} >\n            <DetailedAnswer\n              history={history}\n              onRefresh={onRefresh}\n              selectedQuestion={selectedQuestion}\n            />\n          </FakeSuspense>\n          : null\n        }\n        <section className='show-question__container'>\n          <h4 className='question-title'>\n            {selectedQuestion.title}\n          </h4>\n          <ChoiceText\n            choiceIsMade={checkAlfa}\n            choice={alfaIsTrue}\n            choiceColor={choiceColor}\n            choiceLetter={\"α΄. \"}\n            disabled={choiceSave}\n            choiceText={\"choice_Alpha\"}\n            selectedQuestion={selectedQuestion}\n            saveAnswer={saveAnswer}\n            setStyle={setCheckAlfa}\n            setChoiceSave={setChoiceSave}\n          />\n          <ChoiceText\n            choiceIsMade={checkBeta}\n            choice={betaIsTrue}\n            choiceColor={choiceColor}\n            choiceLetter={\"β΄. \"}\n            disabled={choiceSave}\n            choiceText={\"choice_Beta\"}\n            selectedQuestion={selectedQuestion}\n            saveAnswer={saveAnswer}\n            setStyle={setCheckBeta}\n            setChoiceSave={setChoiceSave}\n          />\n          <ChoiceText\n            choiceIsMade={checkGamma}\n            choiceColor={choiceColor}\n            choice={gammaIsTrue}\n            choiceLetter={\"γ΄. \"}\n            disabled={choiceSave}\n            choiceText={\"choice_Gamma\"}\n            selectedQuestion={selectedQuestion}\n            saveAnswer={saveAnswer}\n            setStyle={setCheckGamma}\n            setChoiceSave={setChoiceSave}\n          />\n          <ChoiceText\n            choiceIsMade={checkDelta}\n            choiceColor={choiceColor}\n            choice={deltaIsTrue}\n            choiceLetter={\"δ΄. \"}\n            disabled={choiceSave}\n            choiceText={\"choice_Delta\"}\n            selectedQuestion={selectedQuestion}\n            saveAnswer={saveAnswer}\n            setStyle={setCheckDelta}\n            setChoiceSave={setChoiceSave}\n          />\n        </section>\n      </article>\n    );\n  }\n};\n\nexport default showQuestion;","import {\n  removeAsyncMultiMixed,\n  removeAsyncTrueFalseMixed,\n  multipleChoiceRemoveAsync,\n  noTimerRemoveAsync,\n  trueFalseRemoveAsync,\n  noTimerTrueFalseRemoveAsync,\n} from \"./removeAsync\";\n\nimport nav from \"../constants/nav\";\n\nconst quitGame = (\n  history: any,\n  gameType: string,\n  timer: boolean,\n  categoryId: string\n) => {\n  const quit = async () => {\n    if (categoryId === \"MultiMixed\") {\n      await removeAsyncMultiMixed();\n    } else if (categoryId === \"TrueFalseMixed\") {\n      await removeAsyncTrueFalseMixed();\n    } else if (gameType === \"Multi\" && timer) {\n      await multipleChoiceRemoveAsync(categoryId);\n    } else if (gameType === \"Multi\" && !timer) {\n      await noTimerRemoveAsync(categoryId);\n    } else if (gameType === \"TrueFalse\" && timer) {\n      await trueFalseRemoveAsync(categoryId);\n    } else if (gameType === \"TrueFalse\" && !timer) {\n      await noTimerTrueFalseRemoveAsync(categoryId);\n    }\n\n    history.push(nav.home); // call it here otherwise you get the finished round screen.\n  };\n  return { quit };\n};\nexport default quitGame","import asynNames from \"../constants/strings\";\nimport { savePoints } from \"../store/actions/game\";\nimport { store } from \"../store/configureStore\";\n\nconst checkAnswerForMixed = async (answerIsCorrect: boolean, totalPoints: number) => {\n  try {\n    let newTotalPoints = totalPoints;\n    if (answerIsCorrect) {\n      newTotalPoints += 1;\n    }\n    store.dispatch(savePoints(newTotalPoints, asynNames.pointsTypeMultiMixed))\n  } catch (err) {\n    // send to custom analytics server\n    throw err;\n  }\n};\nexport default checkAnswerForMixed","import strings from \"../constants/strings\";\n\nimport cache from \"./cache\";\nimport checkAnswerForMixed from \"./checkAnswerForMixed\";\nimport { Question } from '../models/question';\n\nconst checkAnswerHandlerMixedMulti = (\n  selectedQuestion: Question | null,\n  setChoiceColor: Function,\n  setCorrectChoice: Function,\n  setTotalPoints: Function,\n  totalPoints: number\n) => {\n  const saveAnswer = async () => {\n    const alfaIsTrueMixed = await cache.get(strings.alfaIsTrueMultiMixed);\n    const betaIsTrueMixed = await cache.get(strings.betaIsTrueMultiMixed);\n    const gammaIsTrueMixed = await cache.get(strings.gammaIsTrueMultiMixed);\n    const deltaIsTrueMixed = await cache.get(strings.deltaIsTrueMultiMixed);\n\n    let rightChoice = 0;\n    if (!!selectedQuestion) {\n      rightChoice = selectedQuestion.right_choice; // for checking choice;\n    }\n    console.log(\n      \"Mixed\",\n      alfaIsTrueMixed,\n      betaIsTrueMixed,\n      gammaIsTrueMixed,\n      deltaIsTrueMixed,\n      rightChoice\n    );\n\n    let corChoice = false; // For checking the answer when dispatching the checkAnswerFor...\n    if (alfaIsTrueMixed && +rightChoice === 1) {\n      setCorrectChoice(true);\n      setChoiceColor(strings.correctChoiceColor);\n      corChoice = true;\n    } if (betaIsTrueMixed && +rightChoice === 2) {\n      setCorrectChoice(true);\n      setChoiceColor(strings.correctChoiceColor);\n      corChoice = true;\n    } if (gammaIsTrueMixed && +rightChoice === 3) {\n      setCorrectChoice(true);\n      setChoiceColor(strings.correctChoiceColor);\n      corChoice = true;\n    } if (deltaIsTrueMixed && +rightChoice === 4) {\n      setCorrectChoice(true);\n      setChoiceColor(strings.correctChoiceColor);\n      corChoice = true;\n    }\n    if (corChoice) {\n      setTotalPoints(totalPoints + 1);\n\n    }\n    if (!corChoice) {\n      setChoiceColor(strings.wrongChoiceColor);\n    }\n    checkAnswerForMixed(corChoice, totalPoints);\n  };\n\n  return { saveAnswer };\n};\nexport default checkAnswerHandlerMixedMulti;","import { Prompt } from 'react-router-dom'\n\nimport { useState } from \"react\";\nimport { RootStateOrAny, useSelector } from \"react-redux\";\nimport Button from \"../../components/UI/Button\";\nimport Loader from \"../../components/UI/Loader\";\n\nimport '../../styles/game/pages/game-over.css';\n\n// import Colours from \"../../constants/Colours\";\ninterface GameOverPageProps {\n  isUpLoading: boolean,\n  minutesLeft?: number,\n  saveStadiumResult: Function,\n  secondsLeft?: number,\n  stadiumCounter: number,\n  totalPoints: number,\n  timer: boolean,\n}\nconst GameOverPage = ({\n  isUpLoading,\n  minutesLeft,\n  saveStadiumResult,\n  secondsLeft,\n  stadiumCounter,\n  totalPoints,\n  timer,\n}: GameOverPageProps) => {\n  const [hover, setHover] = useState(false);\n  const [gradeSaved, setGradeSaved] = useState(false);\n\n  const userIsLogedIn = useSelector((state: RootStateOrAny) => state.auth.userId);\n\n  const handleHover = () => {\n    setHover(!hover)\n  }\n\n  return (\n    <>\n      <Prompt\n        when={!gradeSaved}\n        message='Αν θέλετε να αποθηκευθεί η βαθμολογία σας στη βάση δεδομένων, πατήστε εδώ άκυρο και μετά στη σελίδα το κουμπί \"Αποθήκευση!\" '\n      />\n      <section className='game-over' >\n        <h2 className='epilogue' >Τέλος καὶ τῷ Θεῷ Δόξα!</h2>\n        <h3 className='stadium' >Στάδιο: {stadiumCounter}ο</h3>\n        <h4 className='grade' >Τελική βαθμολογία: {totalPoints} </h4>\n        {timer && (\n          <>\n            <div onClick={() => {\n              alert(`Η βαθμολογία προκύπτει από το άθροισμα των μονάδων \n(των σωστών απαντήσεων) \nμε τον χρόνο (που απέμεινε) επί 10.`)\n            }}>\n\n              {/* <MaterialIcons\n                  name=\"info-outline\"\n                  size={Math.ceil(width * 0.08)}\n                  color={Colours.maroon}\n                /> */}\n            </div>\n            <h5>\n              Χρόνος που απέμεινε: {minutesLeft}': {secondsLeft}''\n            </h5>\n          </>\n        )}\n        {userIsLogedIn ? (\n          <div className='instruction-text' >\n            <h5>\n              Αποθήκευση αποτελέσματος\n            </h5>\n            <h5>\n              και επιστροφή στην αρχική οθόνη\n            </h5>\n          </div>\n        ) : (\n          <span>Eπιστροφή στην αρχική οθόνη:</span>\n        )}\n        {isUpLoading ? (\n          <Loader />\n        ) : (\n          <Button\n            disabled={false}\n            title='Αποθήκευση'\n            onClick={() => {\n              setGradeSaved(true);\n              saveStadiumResult()\n            }}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n        )}\n      </section>\n    </>\n  );\n};\n\nexport default GameOverPage;\n","\n// import Colours from \"../../constants/Colours\";\nimport Button from \"../../components/UI/Button\";\nimport nav from \"../../constants//nav\";\nimport '../../styles/game/pages/download-error.css';\n\nconst DownloadErrorScreen = ({\n  loadQuestions,\n  history\n}: any) => {\n  return (\n    <section className='download-error' >\n      <h3 className='text1' >Σφάλμα στη διαδικασία φορτώσεως των ερωτήσεων</h3>\n      <h4 className='text2' >Παρακαλούμε ελέγξτε τη σύνδεσή σας</h4>\n      <Button\n        disabled={false}\n        title=\"Δοκιμάστε Ξανά\"\n        onClick={loadQuestions} />\n      <Button\n        disabled={false}\n        title=\"Επιστροφή\"\n        onClick={() => history.push(nav.home)} />\n    </section>\n  );\n};\nexport default DownloadErrorScreen;","import Button from \"../../components/UI/Button\";\nimport nav from \"../../constants/nav\";\nimport '../../styles/game/pages/no-questions-here.css';\n\nconst NoQuestionsHereScreen = (props: any) => {\n  return (\n    <div className='no-questions-here' >\n      <h4 className='text' >Δεν υπάρχουν ερωτήσεις σε αυτή την κατηγορία </h4>\n      <Button\n\n        title=\"Επιστροφή\"\n        onClick={() => props.history.push(nav.home)}\n      />\n    </div>\n  );\n};\nexport default NoQuestionsHereScreen;","import '../../../styles/game/mix/mix-multi-game-no-timer.css'\n\nimport { useState, useEffect, useCallback } from \"react\";\nimport { RootStateOrAny, useDispatch, useSelector } from \"react-redux\";\nimport strings from \"../../../constants/strings\";\n\nimport useLoadQuestionsMixMulti from \"../../../hooks/useLoadQuestionsMixMulti\";\nimport useSaveStadiumResultHandler from \"../../../hooks/useSaveStadiumResultHandler\";\n\nimport showQuestion from \"../../../components/game/showQuestion\";\n\nimport quitGame from \"../../../utils/quitGame\";\nimport { removeChoicesfromAsyncStorage } from \"../../../utils/removeAsync\";\nimport checkAnswerHandlerMixMulti from \"../../../utils/checkAnswerHandlerMixMulti\";\n\nimport GameOverPage from \"../../extras/GameOverPage\";\nimport DownloadErrorScreen from \"../../extras/DownloadErrorScreen\";\nimport NoQuestionsHereScreen from '../../extras/NoQuestionsHereScreen';\nimport { savePoints } from '../../../store/actions/game';\nimport { useHistory } from 'react-router-dom';\n\nconst MixMultiGameNoTimer = (props: any) => {\n  const dispatch = useDispatch();\n  const history: any = useHistory();\n\n  const [modalVisible, setModalVisible] = useState(false);\n\n  const pointsMultiMixed = useSelector((state: RootStateOrAny) => state.game.pointsMultiMixed);\n  const userIsLogedIn = useSelector((state: RootStateOrAny) => state.auth.userId);\n  const email = useSelector((state: RootStateOrAny) => state.auth.email);\n  const gameType = useSelector((state: RootStateOrAny) => state.game.id);\n\n  const [refreshing, setRefreshing] = useState(false);\n  const [showAnswer, setShowAnswer] = useState(false);\n\n  const [choiceSave, setChoiceSave] = useState(false);\n  const [correctChoice, setCorrectChoice] = useState(false);\n\n  const [choiceColor, setChoiceColor] = useState(strings.defaultChoiceColor);\n\n  const [checkAlfa, setCheckAlfa] = useState(false);\n  const [checkBeta, setCheckBeta] = useState(false);\n  const [checkGamma, setCheckGamma] = useState(false);\n  const [checkDelta, setCheckDelta] = useState(false);\n\n  const [stadiumCounter, setStadiumCounter] = useState(1);\n\n  let timer = false;\n\n  // By this we know in TopMenu, which points to display.\n  useEffect(() => {\n    dispatch(savePoints(pointsMultiMixed, strings.pointsTypeMultiMixed))\n  }, [dispatch, pointsMultiMixed])\n\n\n  const {\n    loadQuestions,\n    loadQuestionsError,\n    numOfDownloadedQuestions,\n    numOfTotalQuestions,\n    selectedQuestion,\n    setNumOfTotalQuestions,\n    setStadiumIsFinished,\n    setTotalPoints,\n    stadiumIsFinished,\n    totalPoints,\n  } = useLoadQuestionsMixMulti(timer, gameType);\n\n  const onRefresh = useCallback(async () => {\n    setCorrectChoice(false);\n    setChoiceColor(strings.defaultChoiceColor)\n    setRefreshing(true);\n    setCheckAlfa(false);\n    setCheckBeta(false);\n    setCheckGamma(false);\n    setCheckDelta(false);\n    setChoiceSave(false);\n    setChoiceSave(false);\n    await removeChoicesfromAsyncStorage();\n    // Then\n    loadQuestions();\n    setShowAnswer(false);\n    setRefreshing(false);\n\n    // set num of q/s to finish stadium (100)\n    if (numOfTotalQuestions === 100) {\n      setStadiumIsFinished(true);\n    }\n  }, [setRefreshing, loadQuestions, numOfTotalQuestions, setStadiumIsFinished,]);\n\n  const { quit } = quitGame(\n    history,\n    gameType,\n    timer,\n    /* In games that are not mixed, we use categoryId at the end.\n     Here we hardcode MultiMixed.  */\n    \"MultiMixed\"\n  );\n\n\n  const { isUpLoading, saveStadiumResult } = useSaveStadiumResultHandler(\n    totalPoints,\n    email,\n    userIsLogedIn,\n    gameType,\n    timer,\n    quit,\n    \"MultiMixed\"\n  );\n\n  useEffect(() => {\n    loadQuestions();\n  }, []); // !!! leave the dependencies there and empty !!! \n\n\n  const { saveAnswer } = checkAnswerHandlerMixMulti(\n    selectedQuestion,\n    setChoiceColor,\n    setCorrectChoice,\n    setTotalPoints,\n    totalPoints\n  );\n\n  if (loadQuestionsError) {\n    return (\n      <DownloadErrorScreen\n        loadQuestions={loadQuestions}\n        history={props.history}\n      />\n    );\n  }\n\n  if (numOfTotalQuestions === 1 && selectedQuestion === null) {\n    return (\n      <NoQuestionsHereScreen history={props.history} />\n    );\n  }\n\n  if (stadiumIsFinished) {\n    return (\n      <GameOverPage\n        timer={timer}\n        isUpLoading={isUpLoading}\n        saveStadiumResult={saveStadiumResult}\n        stadiumCounter={stadiumCounter}\n        totalPoints={totalPoints}\n      />\n    );\n  }\n\n  const categoryId = false;\n  return (\n    <article className='mix-multi' >\n      {showQuestion(\n        strings.alfaIsTrueMultiMixed,\n        strings.betaIsTrueMultiMixed,\n        strings.gammaIsTrueMultiMixed,\n        strings.deltaIsTrueMultiMixed,\n        checkAlfa,\n        checkBeta,\n        categoryId,\n        gameType,\n        history,\n        checkGamma,\n        checkDelta,\n        choiceColor,\n        choiceSave,\n        correctChoice,\n        saveAnswer,\n        showAnswer,\n        numOfDownloadedQuestions,\n        numOfTotalQuestions,\n        onRefresh,\n        selectedQuestion,\n        quit,\n        setCheckAlfa,\n        setCheckBeta,\n        setCheckGamma,\n        setCheckDelta,\n        setChoiceSave,\n        setNumOfTotalQuestions,\n        setShowAnswer,\n        setStadiumIsFinished,\n        timer,\n        totalPoints,\n        modalVisible,\n      )}\n    </article>\n  );\n};\n\n\nexport default MixMultiGameNoTimer;\n\n","import '../../../styles/game/mix/mix-multi-game-with-timer.css'\n\nconst MixMultiGameWithTimer = () => {\n  return (\n    <div>\n\n    </div>\n  )\n}\n\nexport default MixMultiGameWithTimer;","import { useCallback, useEffect, useState } from 'react';\nimport { RootStateOrAny, useDispatch, useSelector } from 'react-redux';\nimport { withRouter } from 'react-router-dom';\n\nimport Button from '../../../components/UI/Button';\nimport nav from '../../../constants/nav';\nimport strings from '../../../constants/strings';\nimport cache from '../../../utils/cache';\nimport { removeAsyncMultiMixed, removeAsyncTrueFalseMixed } from '../../../utils/removeAsync';\nimport { gameOn } from '../../../store/actions/game';\nimport '../../../styles/game/mix/game-is-on.css';\n\nconst MixGameIsOn = (props: any) => {\n  const dispatch = useDispatch();\n  const { history } = props;\n  const [hover, setHover] = useState(false);\n  const [mixGameIsOn, setMixGameIsOn] = useState(false);\n  const [mixGameIsOnTF, setMixGameIsOnTF] = useState(false);\n\n  const gameType = useSelector((state: RootStateOrAny) => state.game.id);\n  const timer = useSelector((state: RootStateOrAny) => state.game.timer);\n\n  const handleHover = () => {\n    setHover(!hover)\n  }\n\n\n  useEffect(() => {\n    if (props.location.state.mixGameIsOn) {\n      const isOn = props.location.state.mixGameIsOn;\n      setMixGameIsOn(isOn);\n    }\n    if (props.location.state.mixGameIsOnTF) {\n      const isOn = props.location.state.mixGameIsOnTF;\n      setMixGameIsOnTF(isOn);\n    }\n  }, [props.location.state.mixGameIsOn, props.location.state.mixGameIsOnTF])\n\n\n  const continueSameGameHanlder = useCallback(\n    async () => {\n      await dispatch(gameOn(true));\n      if (gameType === \"Multi\") {\n        if (timer) {\n          await cache.set(strings.useTimerMultiMixed, true);\n          history.replace(nav.mixMultiGameWithTimer);\n        } else {\n          await cache.set(strings.useTimerMultiMixed, false);\n          history.replace(nav.mixMultiGameNoTimer);\n        }\n      } else if (gameType === \"TrueFalse\") {\n        if (timer) {\n          await cache.set(strings.useTimerTrueFalseMixed, true);\n          history.replace(nav.mixTrueFalseGameWithTimer);\n        } else {\n          await cache.set(strings.useTimerTrueFalseMixed, false);\n          history.replace(nav.mixTrueFalseGameNoTimer);\n        }\n      }\n    }, [gameType, dispatch, history, timer])\n\n\n  const startNewGameHandler = async () => {\n    if (gameType === \"TrueFalse\") await removeAsyncTrueFalseMixed();\n    else await removeAsyncMultiMixed();\n    history.replace(nav.mixChooseCategories);\n  }\n\n  return (\n    <article className='game-is-on' >\n      <section className='game-is-on__container' >\n        <p className='game-is-on__text1' >{`\nΈχετε ένα παιχνίδι \n${mixGameIsOn || mixGameIsOnTF ? \"με χρόνο\" : \"χωρίς χρόνο\"} \nήδη σε εξέλιξη`}</p>\n        <p className='game-is-on__text2' >{`\nΘέλετε να συνεχίσετε το ίδιο, \nή να ξεκινήσετε καινούριο; \n`}</p>\n        <div className='game-is-on__buttons-container' >\n          <Button\n            style={{ width: 120, margin: 30 }}\n            disabled={false}\n            title=\"Το ίδιο\"\n            onClick={continueSameGameHanlder}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n          <Button\n            style={{ width: 120, margin: 30 }}\n            disabled={false}\n            title=\"Kαινούριο\"\n            onClick={startNewGameHandler}\n            onMouseEnter={() => handleHover()}\n            onMouseLeave={() => handleHover()}\n          />\n        </div>\n      </section>\n    </article>\n  )\n}\n\nexport default withRouter(MixGameIsOn);","import { useEffect, useState } from 'react';\nimport { RootStateOrAny, useSelector } from \"react-redux\";\nimport { Route, Switch, Redirect, useHistory, } from 'react-router-dom';\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport { createBrowserHistory } from 'history';\nimport { CSSTransition, TransitionGroup } from 'react-transition-group';\n\nimport Menu from \"./pages/menu/Menu\";\nimport Home from \"./pages/Home\";\nimport Winners from \"./pages/menu/Winners\";\nimport Settings from \"./pages/menu/Settings\";\nimport Create from \"./pages/menu/Create\";\nimport NotFound from \"./pages/NotFound\";\nimport Auth from './pages/Auth/Auth';\nimport Topbar from './components/Topbar';\nimport './styles/app.css';\n\nimport strings from './constants/strings';\nimport Donate from './pages/menu/Donate';\nimport nav from './constants/nav';\nimport MultiCategories from './pages/game/MultiCategories';\nimport MultiCategoriesNoTimer from './pages/game/MultiCategoriesNoTimer';\nimport MixChooseCategories from './pages/game/mix/MixChooseCategories';\nimport MultiGameNoTimer from './pages/game/multi/MultiGameNoTimer';\nimport MixMultiGameNoTimer from './pages/game/mix/MixMultiGameNoTimer';\nimport MixMultiGameWithTimer from './pages/game/mix/MixMultiGameWithTimer';\nimport MixGameIsOn from './pages/game/mix/MixGameIsOn';\nexport const history = createBrowserHistory();\n\nfunction App() {\n  const history = useHistory();\n  const [menuOpen, setMenuOpen] = useState<boolean>(false);\n  const allowEntrance = useSelector((state: RootStateOrAny) => state.auth.allowEntrance)\n\n  const userLoggedIn = localStorage.getItem(strings.userData);\n\n  useEffect(() => {\n    document.addEventListener(\"mousedown\", () => {\n      setMenuOpen(false);\n    });\n  });\n\n  return (\n    <Router  >\n      <div className=\"app\">\n        {!!userLoggedIn || allowEntrance ? <Topbar menuOpen={menuOpen} setMenuOpen={setMenuOpen} /> : null}\n        {!!userLoggedIn || allowEntrance ? <Menu menuOpen={menuOpen} setMenuOpen={setMenuOpen} /> : null}\n        <div className=\"app__content\">\n          <Route render={({ location }) =>\n          (\n            <TransitionGroup>\n              <CSSTransition\n                key={location.key}\n                // in={inProp} \n                timeout={1000}\n                classNames=\"fade\"\n                mountOnEnter={true}\n                unmountOnExit={true}\n              >\n                <Switch location={location} >\n                  {/* Menu */}\n                  <Route path={nav.auth} component={Auth} />\n                  <Route path={nav.winners} component={Winners} />\n                  <Route path={nav.settings} component={Settings} />\n                  <Route path={nav.create} component={Create} />\n                  <Route path={nav.donate} component={Donate} />\n\n                  {/* Categories */}\n                  <Route path={nav.multiCategories} component={MultiCategories} />\n                  <Route\n                    path={nav.multiCategoriesNoTimer}\n                    render={() => <MultiCategoriesNoTimer history={history} />}\n                  />\n\n                  {/* Games */}\n\n                  {/* Mix */}\n                  <Route path={nav.mixChooseCategories} component={MixChooseCategories} />\n                  <Route path={nav.mixMultiGameNoTimer} component={MixMultiGameNoTimer} />\n                  <Route path={nav.mixMultiGameWithTimer} component={MixMultiGameWithTimer} />\n\n                  <Route path={nav.mixGameIsOn} render={() => <MixGameIsOn history={history} />} />\n\n                  {/* Multi */}\n                  <Route path={nav.multiGameNoTimer} component={MultiGameNoTimer} />\n\n\n                  {/* Basic */}\n                  <Route path={nav.home} exact render={() => <Home setMenuOpen={setMenuOpen} />} />\n                  <Route path={nav.not_found} component={NotFound} />\n                  <Redirect to={nav.not_found} />\n                </Switch>\n              </CSSTransition>\n            </TransitionGroup>\n          )} />\n\n        </div>\n      </div>\n    </Router>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { PersistGate } from 'redux-persist/integration/react';\n\nimport configureStore from \"./store/configureStore\";\n\n\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nconst { store, persistor } = configureStore();\n\nReactDOM.render(\n  <React.StrictMode>\n    <Provider store={store}>\n      <PersistGate loading={null} persistor={persistor}>\n        <App />\n      </PersistGate>\n    </Provider>\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}